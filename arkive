#!/usr/bin/env zsh
#
#                                  Arkive
#
# Copyright (c) 2013-2016, Cody Opel <codyopel@gmail.com>
# All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# WARNING:
# This script is meant as a stopgap solution until another project I am working
# on is in a usable state, at which time this will be discontinued.

ARKIVE_VERSION=4
ARKIVE_BIT_STREAM_VERSION=2
VERSION="${ARKIVE_VERSION}.${ARKIVE_BIT_STREAM_VERSION}"

############
# Defaults #
############
# Debugging
ARKIVE_DEBUG=false
# Container format (mkv,mp4,ogv,webm)
ARKIVE_CONTAINER='mkv'
# Video Codec (daala,h264,h265,vp9)
ARKIVE_VIDEO_CODEC='h265'
# Bits Per Pixel (used to dynamically determine bitrate)
# Based on ((1920 * 1080 * 24000/1001 * <bpp>) / 1000)
ARKIVE_VIDEO_BITS_PER_PIXEL='' # Based on <bitrate>kbps @ 1080p
# Bits per channel color (8,10,12)
ARKIVE_VIDEO_BIT_DEPTH=10
# Chroma Subsampling (420,422,444)
ARKIVE_VIDEO_CHROMA_SUBSAMPLING=420
# Multi-pass video encoding (1-3)
ARKIVE_VIDEO_ENCODING_PASSES=2
# Audio Codec (aac,ac3,flac,opus)
ARKIVE_AUDIO_CODEC='opus'
# Bitrate per audio channel in kbps (5.1 -> 6 * 64 = 384),
# Ignored if `flac` codec is specified
ARKIVE_AUDIO_CHANNEL_BITRATE=64
# Audio default language (ISO 639-2/B)
ARKIVE_AUDIO_LANG_DEFAULT='eng'
#### Audio languages to include (ISO 639-2/B)
###ARKIVE_SUBTITLES_LANGS=('eng')
# Subtitles, NOT IMPLEMENTED
ARKIVE_SUBTITLES=true
# Subtitles default language (ISO 639-2/B)
ARKIVE_SUBTITLES_LANG_DEFAULT='eng'
# Subtitle languages to include (ISO 639-2/B)
ARKIVE_SUBTITLES_LANGS=('eng')
# Subtitle codec (ass,srt)
ARKIVE_SUBTITLE_CODEC='ass'
# Chapters, NOT IMPLEMENTED
ARKIVE_CHAPTERS=true

SUPPORTED_CONTAINER_EXTENSIONS=(
  'avi'
  'f4v'
  'flv'
  # `m2ts` is only supported if no more than one audio or subtitle stream are
  # found, m2ts does not contain language codes to differentiate between them.
  'm2ts'
  'm4v'
  'mkv'
  'mov'
  'mp4'
  'mpeg'
  'mpg'
  'ts'
  'webm'
  'wmv'
)

TMP_FILES=()
unset FAILURE

function arkive_usage {

cat <<ARKIVEUSAGE
Arkhive version: ${VERSION}

Usage: arkhive [OPTIONS] FILE [OPTIONS]
  * -i|--input  FILE/DIRECTORY - add input file/directory
    -o|--output DIRECTORY      - set output directory
    -t|--tmp   DIRECTORY       - set tmp directory
ARKIVEUSAGE

  return 0

}

function err_call_stack {

  # Return the name of the executing function

  # Take into account the function calls and the name you expect to return,
  # hense it returns 3, not 1 (also zsh arrays start from 1, not 0)
  echo "${funcstack[3]}"

  return 0

}

function err_error {

  # Return a formatted error message

  if [[ -n "${2}" ]] ; then
    # Allow returning a custom function/script error
    echo "Arkive: ERROR in \`${2}\`: ${1}" > /dev/stderr
  else
    echo "Arkive: ERROR in \`$(err_call_stack)\`: ${1}" > /dev/stderr
  fi

  return 0

}

function err_warn {

  # Return a formatted warning message

  if [[ -z "${FAILURE}" ]] ; then
    export FAILURE="${1}"
  fi

  if [[ -n "${2}" ]] ; then
    # Allow returning a custom function/script warning
    echo "Arkive: WARNING in \`${2}\`: ${1}" > /dev/stderr
  else
    echo "Arkive: WARNING in \`$(err_call_stack)\`: ${1}" > /dev/stderr
  fi

  return 0

}

function path_bin_abs {

  # Resolves the absolute path of the binary

  local Bin

  Bin="$(
    whereis -b ${1} 2> /dev/null |
      awk '{print $2 ; exit}'
  )"

  if [[ -z "${Bin}" ]] ; then
    return 1
  fi

  echo "${Bin}"

  return 0

}

function path_hasbin {

  # Test to see if a binary exists in the path

  if [[ $# -ne 1 ]] ; then
    return 2
  fi

  whence -p "${1}" > /dev/null 2>&1 || return 1

  return 0

}

function to_lower {

  echo $@ | tr '[A-Z]' '[a-z]'

  return 0

}

function shell {

  # Returns the shell executing the current script

  # TODO: fix failure on FreeBSD returning null

  local FindShell
  local FindProc

  FindProc="$(
    ps hp $$ |
      grep "$$"
  )"

  # Workaround for su spawned shells
  if [[ -n "$(echo "${FindProc}" | grep '\-su')" ]] ; then
    FindShell="$(
      basename "$(
        echo "${FindProc}" |
          sed 's/^.*(\([^)]*\)).*$/\1/'
      )"
    )"
  else
    FindShell="$(
      basename "$(
        echo "${FindProc}" |
          sed 's/-//' |
          awk '{print $5 ; exit}'
      )"
    )"
  fi

  # Resolve symlinked shells
  FindShell="$(
    basename "$(
      readlink -f "$(
        path_bin_abs "${FindShell}"
      )"
    )"
  )"

  # Remove appended major version
  FindShell="$(
    echo "${FindShell}" |
      sed 's/^\([a-z]*\).*/\1/'
  )"

  FindShell="$(
    to_lower "${FindShell}"
  )"

  echo "${FindShell}"

  return 0

}

function requires {

  # Required dependencies

  # ffmpeg >= 2.7 (for 10bit libx265 support)
  #   libx264 (compiled with target bit depth)
  #   libx265 >= 1.9 (compiled with multilib or at least target bit depth)
  path_hasbin 'ffmpeg' || {
    err_error "`ffmpeg` is not installed"
    return 1
  }

  # Optional, used to convert bitmap subs to plain text
  # if not available, bitmap subs are ignored
  path_hasbin 'vobsub2srt' || {
    err_error "`vobsub2srt` is not installed"
    return 1
  }

  # zsh >= 5.0.6 (uses zparseopts)
  path_hasbin 'zsh' || {
    err_error "`zsh` is not installed"
    return 1
  }

  # Check for zsh as executing shell
  if [[ "$(shell)" != 'zsh' ]] ; then
    err_error 'script must be executed with `zsh`'
    return 1
  fi

  return 0

}

function cpu_sockets {

  local Sockets

  Sockets="$(
    lscpu |
      grep --max-count 1 'Socket(s):' |
      grep --only-matching --perl-regexp "[0-9]+"
  )"

  if [[ ! ${Sockets} -ge 1 ]] ; then
    # Assume a socket exists even if it fails to find any
    Sockets=1
  fi

  echo "${Sockets}"

  return 0

}

function cpu_physical {

  # Find number of physical cpu cores

  # Assumes all sockets are identical, only some arm platforms won't
  # work with this logic.

  local CpuCores

  CpuCores=$(
    lscpu |
      grep --max-count 1 'Core(s) per socket:' |
      grep --only-matching --perl-regexp '[0-9]+'
  )

  if [[ ! ${CpuCores} -ge 1 ]] ; then
    CpuCores=1
  else
    CpuCores=$(( ${CpuCores} * $(cpu_sockets) ))
  fi

  echo "${CpuCores}"

  return 0

}

function cpu_logical {

  # Find number of logical cpu cores

  # Assumes all sockets are identical, only some arm platforms won't
  # work with this logic

  local CpuThreads

  # Finds number of logical threads per physical core
  CpuThreads=$(
    lscpu |
      grep --max-count 1 'Thread(s) per core:' |
      grep --only-matching --perl-regexp '[0-9]+'
  )
  if [[ ${CpuThreads} -ge 1 ]] ; then
    # Convert to number of threads per cpu
    CpuThreads=$((${CpuThreads} * $(cpu_physical)))
  fi

  if [[ ! ${CpuThreads} -ge 1 ]] ; then
    CpuThreads=$(cpu_physical)
  else
    CpuThreads=$((${CpuThreads} * $(cpu_sockets)))
  fi

  echo "${CpuThreads}"

  return 0

}

function input_parser {

  # Parses, validates, and exports input

  local Item
  local InputFileSupported
  local UserInputList
  local UserOutputDir
  local UserTmpDir

  INPUT_FILES=()

  if [[ -z "${@}" ]] ; then
    err_error 'no input'
    echo
    arkive_usage
    return 1
  fi

  builtin zparseopts -D -E -- \
    i+:=UserInputList -input+:=UserInputList \
    o:=UserOutputDir -output:=UserOutputDir \
    t:=UserTmpDir -tmp:=UserTmpDir
    # h -help

  if [[ -z "${UserInputList}" ]] ; then
    err_error 'no input files specified'
    echo
    arkive_usage
    return 1
  fi

  # Drop flags from array (e.g. `-i` & `--input`)
  UserInputList=("${(@)UserInputList:#-i}")
  UserInputList=("${(@)UserInputList:#--input}")
  UserOutputDir="${UserOutputDir#-o[ ]}"
  UserOutputDir="${UserOutputDir#--output[ ]}"
  UserTmpDir="${UserTmpDir#-t[ ]}"
  UserTmpDir="${UserTmpDir#--tmp[ ]}"

  # Drop = incause user used --input=filename
  # TODO: file `=` in input array, need to eval ~ -> path
  UserInputList=("${(@)UserInputList:#*=}")
  eval UserOutputDir="${UserOutputDir#*=}"
  eval UserTmpDir="${UserTmpDir#*=}"

  # Make sure user did not pass `--flag=''`, if so ignore flag
  if [[ -z "${UserOutputDir}" && -n ${UserOutputDir+x} ]] ; then
    unset UserOutputDir
  fi
  if [[ -z "${UserTmpDir}" && -n ${UserTmpDir+x} ]] ; then
    unset UserTmpDir
  fi

  # Check $UserInputList for validity

  # Make sure output dir exists if specified
  if [[ -n ${UserOutputDir+x} && ! -d "${UserOutputDir}" ]] ; then
    err_error "output location is not a directory: ${UserOutputDir}"
    return 1
  fi

  # Make sure tmp dir exists if specified
  if [[ -n ${UserTmpDir+x} && ! -d "${UserTmpDir}" ]] ; then
    err_error "tmp location is not a directory: ${UserTmpDir}"
    return 1
  fi

  # Parses UserInputList and creates a list of only supported files
  for Item in "${UserInputList[@]}" ; do
    #eval Item="${Item#*=}"
    if [[ -f "${Item}" ]] ; then
      InputFileSupported=false
      for CONTAINER in "${SUPPORTED_CONTAINER_EXTENSIONS[@]}" ; do
        currentItemExtension="${Item##*.}"
        if [[ "${currentItemExtension}" == "${CONTAINER}" ]] ; then
          InputFileSupported=true
          break
        fi
      done
      # Add check for valid extension
      if ${InputFileSupported} ; then
        # TODO: get full path to file before adding to the array
        INPUT_FILES+=("${Item}")
      else
        err_warn "not a supported file type: ${Item}"
      fi
    # TODO: add support for directories
    elif [[ -d "${Item}" ]] ; then
      # find all files in dir (don't check for file extensions here)
      inputFilesFound=( "$(find "${Item}" -print)" )
      InputFileSupported=false
      for CONTAINER in "${SUPPORTED_CONTAINER_EXTENSIONS[@]}" ; do
        currentItemExtension="${Item##*.}"
        if [[ "${currentItemExtension}" == "${CONTAINER}" ]] ; then
          InputFileSupported=true
          break
        fi
      done
      err_error 'support for directories not implemented'
      return 1
    else
      err_warn "not a valid file or directory: ${Item}"
    fi
  done

  # Use the full path to the output dir
  if [[ -n "${UserOutputDir}" ]] ; then
    pushd "${UserOutputDir}"
    OUTPUT_DIR="$(pwd)"
    popd
  fi

  # Use the full path to the tmp dir
  if [[ -n "${UserTmpDir}" ]] ; then
    pushd "${UserTmpDir}"
    TMP_DIR="$(pwd)"
    popd
  fi

  return 0

}

function input_directory {

  local InputDirectory

  pushd "$(dirname "${CurrentFile}")"
  InputDirectory="$(pwd)"
  popd

  if [[ ! -d "${InputDirectory}" ]] ; then
    err_error 'directory does not exist: ${InputDirectory}'
    return 1
  fi

  echo "${InputDirectory}"

  return 0

}

function output_directory {

  local OutputDirectory

  if [[ -z "${OUTPUT_DIR}" ]] ; then
    OutputDirectory="$(input_directory)"
  else
    pushd "${OUTPUT_DIR}"
    OutputDirectory="$(pwd)"
    popd
  fi

  if [[ ! -d "${OutputDirectory}" ]] ; then
    err_error 'directory does not exist: ${OutputDirectory}'
    return 1
  fi

  echo "${OutputDirectory}"

  return 0

}

function tmp_directory {

  local TmpDirectory

  if [[ -z "${TMP_DIR}" ]] ; then
    TmpDirectory="$(output_directory)"
  else
    pushd "${TMP_DIR}"
    TmpDirectory="$(pwd)"
    popd
  fi

  if [[ ! -d "${TmpDirectory}" ]] ; then
    err_error 'directory does not exist: ${TmpDirectory}'
    return 1
  fi

  echo "${TmpDirectory}"

  return 0

}

function filename_orginal {

  # Format filename w/ ext, w/ no path

  basename "${1}" || return 1

  return 0

}

function filename_original_base {

  # Format filename w/o ext, w/ no path

  basename "${1}" | sed -r 's/\.[[:alnum:]]+$//' || return 1

  return 0

}

function filename_formatted_base {

  local Filename
  local ArkMark

  # TODO: eventually this should handle more parsing, but for now,
  #       fuck it, ship it

  Filename="$(filename_original_base "${1}")" || return 1
  ArkMark='-ARK'

  echo "${Filename}${ArkMark}"

  return 0

}

function audio_stream_selector {

  # Selects the audio stream to use if multiple exist

  local Bitrate
  local BitrateAsocArray
  local BitrateBest
  local ChannelLayout
  local ChannelLayoutAsocArray
  local ChannelLayoutBest
  local Channels
  local ChannelsAsocArray
  local ChannelsBest
  local Stream
  local Streams
  local SampleRate
  local SampleRateAsocArray
  local SampleRateBest

  BitrateAsocArray=()
  ChannelLayoutAsocArray=()
  ChannelsAsocArray=()
  SampleRateAsocArray=()
  typeset -A OptimumAsocArray

  # Add stream ID of all audio streams to array
  #  TODO: add error
  Streams=($(
    ffprobe \
      -v error \
      -select_streams a \
      -show_entries stream=index \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+' || {
        err_error 'asdfasdf'
        return 1
      }
  ))

  if [[ -z "${Streams[1]}" ]] ; then
    err_error 'no audio streams found, at least 1 is required'
    return 1
  fi

  # If multiple audio streams exist, select the correct one
  if [[ ${#Streams[@]} -gt 1 ]] ; then
    echo "${Streams[@]}"
    # TODO: add support for multiple audio streams.
    #       only one maybe used in the output
    for Stream in ${Streams[@]} ; do
      # Check sample rate
      sampleRate=$(audio_sample_rate "${Stream}") || {
        sampleRate=0
      }
      #OptimumAsocArray+=("sample_rate${Stream}" "${sampleRate}")

      # Check number of channels
      Channels=$(audio_channels "${Stream}") || {
        Channels=0
      }
      OptimumAsocArray["channels${Stream}"]=${Channels}

      # Check channel layout
      ChannelLayout=$(audio_channel_layout "${Stream}") || {
        layout=0
      }
      #OptimumAsocArray+=("channel_layout${Stream}" "${ChannelLayout}")

      # Check language
        # add function for manguage code
      # Check bitrate
      Bitrate=$(audio_bitrate) || {
        bitrate=0
      }
      #OptimumAsocArray+=("bit_rate${Stream}" "${Bitrate}")

      # Check audio codec
      # Check duration
    done

    echo "${OptimumAsocArray["channels1"]}"

    for Stream in "${Streams[@]}" ; do

      key="channel${Stream}"

    done
    #BitrateBest=
    #SampleRateBest
    #ChannelsBest
    #ChannelLayoutBest
    #StreamOrginalIndex
    #StreamLanguage

    # Pick optimal stream
    err_error 'multiple audio streams not implemented'
    return 1
  else
    Stream=${audioStreams[1]}
  fi

  echo "${Stream}"

  return 0

}

function audio_sample_rate {

  local SampleRate
  local Stream

  Stream="${1}"

  SampleRate=$(
    ffprobe \
      -v error \
      -select_streams "a:${Stream}" \
      -show_entries stream=sample_rate \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  )

  if [[ -z "${SampleRate}" ]] ; then
    return 1
  fi

  echo "${SampleRate}"

  return 0

}

function audio_bitrate {

  local Bitrate
  local Stream

  Stream="${1}"

  Bitrate=$(
    ffprobe \
      -v error \
      -select_streams "a:${Stream}" \
      -show_entries stream=bit_rate \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  )

  if [[ -z "${Bitrate}" ]] ; then
    return 1
  fi

  echo "${Bitrate}"

  return 0

}

function audio_bitrate_output {

  # TODO: check for integer (make sure audio_channels is not null)

  local Bitrate
  local Channels

  Channels="$(audio_channels_output)" || return 1

  if [[ -z "${Channels}" ]] ; then
    err_error 'channels'
    return 1
  fi

  Bitrate=$(( ${Channels} * ${ARKIVE_AUDIO_CHANNEL_BITRATE} ))

  if [[ ! ${Bitrate} -ge 16 ]] ; then
    return 1
  fi

  echo "-b:a ${Bitrate}k"

  return 0

}

function audio_channels {

  local Channels
  local Stream

  Stream="${1}"

  Channels=$(
    ffprobe \
      -v error \
      -select_streams "a:${Stream}" \
      -show_entries stream=channels \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  )

  if [[ -z "${Channels}" ]] ; then
    return 1
  fi

  echo "${Channels}"

  return 0

}

function audio_channel_layout {

  local ChannelLayout
  local Stream

  Stream="${1}"

  ChannelLayout=$(
    ffprobe \
      -v error \
      -select_streams "a:${Stream}" \
      -show_entries stream=channel_layout \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}"
  )

  if [[ -z "${ChannelLayout}" ]] ; then
    return 1
  fi

  echo "${ChannelLayout}"

  return 0

}

function audio_filters {
  return 0
}

function audio_channels_output {

  local Channels
  local ChannelLayoutSource
  local Stream

  Stream="$(audio_stream_selector)" || return 1

  ChannelLayoutSource="$(audio_channel_layout ${Stream})" || return 1

  # Determine output audio channel count
  # (these are all sperate arguments to allow restructuring in the future)
  case "${ChannelLayoutSource}" in
    'mono') # 1 -> 2
      Channels=2
      ;;
    'stereo') # 2 -> 2
      Channels=2
      ;;
    '2.1') # 3 -> 2
      Channels=2
      ;;
    '3.0') # 3 -> 2
      Channels=2
      ;;
    '3.0(back)') # 3 -> 2
      Channels=2
      ;;
    '4.0') # 4 -> 2
      Channels=2
      ;;
    'quad') # 4 -> 6
      Channels=6
      ;;
    'quad(side)') # 4 -> 6
      Channels=6
      ;;
    '3.1') # 4 -> 2
      Channels=2
      ;;
    '4.1') # 5 -> 2
      Channels=2
      ;;
    '5.0') # 5 -> 6
      Channels=6
      ;;
    '5.0(side)') # 5 -> 6
      Channels=6
      ;;
    '5.1') # 6 -> 6
      Channels=6
      ;;
    '5.1(side)') # 6 -> 6
      Channels=6
      ;;
    '6.0') # 6 -> 6
      Channels=6
      ;;
    '6.0(front)') # 6 -> 6
      Channels=6
      ;;
    'hexagonal') # 6 -> 6
      Channels=6
      ;;
    '6.1') # 7 -> 6
      Channels=6
      ;;
    '6.1(back)') # 7 -> 6
      Channels=6
      ;;
    '6.1(front)') # 7 -> 6
      Channels=6
      ;;
    '7.0') # 7 -> 6
      Channels=6
      ;;
    '7.0(front)') # 7 -> 6
      Channels=6
      ;;
    '7.1') # 8 -> 6
      Channels=6
      ;;
    '7.1(wide)') # 8 -> 6
      Channels=6
      ;;
    '7.1(wide-side)') # 8 -> 6
      Channels=6
      ;;
    'octagonal') # 8 -> 6
      Channels=6
      ;;
    'downmix') # 2 -> 2
      Channels=2
      ;;
    *)
      err_error "Unsupported channel layout"
      return 1
      ;;
  esac

  echo "${Channels}"

  return 0

}

function audio_codec {

  local codec

  case "${ARKIVE_AUDIO_CODEC}" in
    'ac3')
      codec='ac3'
      ;;
    'aac')
      codec='libfdk_aac'
      ;;
    'ffaac')
      codec='aac'
      ;;
    'opus')
      codec='libopus'
      ;;
    'flac')
      codec='flac'
      ;;
    *)
      return 1
      ;;
  esac

  echo "-c:a ${codec}"

  return 0

}

function audio_args {

  # TODO: add stream mapping

  local Bitrate
  local Channels
  local Filters
  local Codec

  Bitrate="$(audio_bitrate_output)" || return 1
  Channels="$(audio_channels_output)" || return 1
  Filters="$(audio_filters)" || return 1
  Codec="$(audio_codec)" || return 1

  echo "${Bitrate} ${Codec} ${Filters} -ac ${Channels}"

  return 0

}

function subtitle_stream_selector {

  # Selects the audio stream to use if multiple exist

  local SubtitleStream
  local SubtitleStreams

  SubtitleStreams=($(
    ffprobe \
      -v error \
      -select_streams s \
      -show_entries stream=index \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  ))

  if [[ -z "${SubtitleStreams[1]}" ]] ; then
    return 1
  fi

  # If multiple subtitle streams exist
  if [[ ${#SubtitleStreams[@]} -gt 1 ]] ; then
    # TODO: add support for multiple subtitle streams
    err_error 'multiple subtitle streams not implemented'
    return 1
  else
    SubtitleStream=${SubtitleStreams[1]}
  fi

  echo "${SubtitleStream}"

  return 0

}

function video_stream_selector {

  # Selects the video stream to use if multiple exist

  local VideoStream
  local VideoStreams

  VideoStreams=($(
    ffprobe \
      -v error \
      -select_streams v \
      -show_entries stream=index \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  ))

  if [[ -z "${VideoStreams[1]}" ]] ; then
    err_error 'no video streams found'
    return 1
  fi

  # If multiple video streams exist, select the correct one
  if [[ ${#VideoStreams[@]} -gt 1 ]] ; then
    # TODO: add support for multiple video streams.
    #       only one maybe used in the output
    # - need size, length, & resolution comparisons
    err_error 'multiple videos streams not implemented'
    return 1
  else
    VideoStream=${VideoStreams[1]}
  fi

  echo "${VideoStream}"

  return 0

}

function video_source_height {

  local Height
  local Stream

  Stream="$(video_stream_selector)" || return 1

  Height=$(
    ffprobe \
      -v error \
      -select_streams v:${Stream} \
      -show_entries stream=height \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp '[0-9]+'
  )

  if [[ -z "${Height}" ]] ; then
    err_error 'could not find height of source video'
    return 1
  fi

  echo "${Height}"

  return 0

}

function video_source_width {

  local Width
  local Stream

  Stream="$(video_stream_selector)" || return 1

  Width=$(
    ffprobe \
      -v error \
      -select_streams v:${Stream} \
      -show_entries stream=width \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}" |
      grep --only-matching --perl-regexp "[0-9]+"
  )

  if [[ -z "${Width}" ]] ; then
    err_error 'could not find width of source video'
    return 1
  fi

  echo "${Width}"

  return 0

}

function video_filter_black_bar_crop {

  # Uses the ffmpeg cropdetect filter to check for blackbars at 5 second
  # intervals until 10 identical results for both width and height are found.

  # TODO:
  # - fix setting crop rounding value dynamically
  #   h264: prefer multiples of 16 for compression efficiency, or multiple
  #     of 2, 4, or 8?
  #   h265: use multiple of min CU size
  #   vp9: multiple of 16, cite bug

  local CropDetect
  local CropHeight
  local CropHeightArray
  local CropHeightMatches
  local CropWidth
  local CropWidthArray
  local CropWidthMatches
  local CropXOffset
  local CropXOffsetArray
  local CropYOffset
  local CropYOffsetArray
  local LoopIter
  local Skip
  local SourceHeight
  local SourceWidth
  local Stream

  CropHeight=0
  CropHeightArray=()
  CropHeightMatches=0
  CropWidth=0
  CropWidthArray=()
  CropWidthMatches=0
  CropXOffsetArray=()
  CropXOffsetMatches=0
  CropYOffsetArray=()
  CropYOffsetMatches=0
  LoopIter=1
  SourceHeight=$(video_source_height) || return 1
  SourceWidth=$(video_source_width) || return 1

  if [[ ! -f "${CurrentFile}" ]] ; then
    err_error "file does not exist: ${CurrentFile}"
    return 1
  fi

  function mode {
    echo "${@}" |
      sed -r 's/[[:space:]]+/\n/g' |
      uniq -c |
      sort -n -k 1 -r |
      awk '{ print $2 ; exit }'
  }

  function mode_count {
    echo "${@}" |
      sed -r 's/[[:space:]]+/\n/g' |
      uniq -c |
      sort -n -k 1 -r |
      awk '{ print $1 ; exit }'
  }

  Stream="$(video_stream_selector)" || return 1

  while [[ ${CropHeightMatches} -lt 5 && \
           ${CropWidthMatches} -lt 5 && \
           ${CropXOffsetMatches} -lt 5 && \
           ${CropYOffsetMatches} -lt 5 ]] ; do
    Skip=$(( ${LoopIter} * 5 ))
    # https://ffmpeg.org/pipermail/ffmpeg-user/2011-July/001795.html
    # https://ffmpeg.org/pipermail/ffmpeg-user/2012-August/008767.html
    # -ss before -i uses seeking, -ss after -i uses skipping and is very slow
    CropDetect="$(
      ffmpeg \
        -threads "${CPU_THREADS}" \
        -ss ${Skip} \
        -i "${CurrentFile}" \
        -ss 0 \
        -t 1 \
        -an \
        -filter:v:${Stream} cropdetect=30:0:0 \
        -f null - 2>&1 |
        awk -F "=" '/crop/ { print $NF }' |
        tail -1 || {
          err_error 'ffmpeg failed'
        }
    )"

    # Find crop height
    CropHeight=$(echo "${CropDetect}" | awk -F ':' '{ print $2 ; exit }')
    # Find crop width
    CropWidth=$(echo "${CropDetect}" | awk -F ':' '{ print $1 ; exit }')
    # Sanity check
    if [[ ${CropHeight} -gt $(( ${SourceHeight} / 2 )) && \
          ${CropWidth} -gt $(( ${SourceWidth} / 2 )) ]] ; then
      CropXOffsetArray+=(
        "$(echo "${CropDetect}" | awk -F ':' '{ print $3 ; exit }')"
      )
      CropYOffsetArray+=(
        "$(echo "${CropDetect}" | awk -F ':' '{ print $4 ; exit }')"
      )
      CropHeightArray+=("${CropHeight}")
      CropWidthArray+=("${CropWidth}")
    fi

    # Find count of mode values
    CropWidthMatches=$(mode_count "${CropWidthArray[@]}")
    CropHeightMatches=$(mode_count "${CropHeightArray[@]}")
    CropXOffsetMatches=$(mode_count "${CropXOffsetArray[@]}")
    CropYOffsetMatches=$(mode_count "${CropYOffsetArray[@]}")

    LoopIter=$(( ${LoopIter} + 1 ))

    # Exit if cropdetect is probably failing to prevent infinite loops
    if [[ ${LoopIter} -gt 50 ]] ; then
      err_error 'cropdetect filter failed'
      return 1
    fi
  done

  # Find crop width mode
  CropWidth=$(mode "${CropWidthArray[@]}")
  if [[ -z "${CropWidth}" ]] ; then
    err_error 'CropWidth returned value null'
    return 1
  fi

  # Find crop height mode
  CropHeight=$(mode "${CropHeightArray[@]}")
  if [[ -z "${CropHeight}" ]] ; then
    err_error 'CropHeight returned value null'
    return 1
  fi

  # Find X offset mode
  CropXOffset=$(mode "${CropXOffsetArray[@]}")
  if [[ -z "${CropXOffset}" ]] ; then
    err_error 'CropXOffset returned value null'
    return 1
  fi

  # Find Y offset mode
  CropYOffset=$(mode "${CropYOffsetArray[@]}")
  if [[ -z "${CropYOffset}" ]] ; then
    err_error 'CropYOffset returned value null'
    return 1
  fi

  echo "crop=${CropWidth}:${CropHeight}:${CropXOffset}:${CropYOffset}"

  return 0

}

function video_filters {

  local BlackBarCrop
  local Filter
  local FilterList
  local Filters

  Filters=()

  BlackBarCrop="$(video_filter_black_bar_crop)" || return 1

  Filters+=(
    "${BlackBarCrop}"
  )

  for Filter in "${Filters[@]}" ; do
    if [[ -n "${Filter}" ]] ; then
      FilterList="${FilterList}${FilterList:+,}${Filter}"
    fi
  done

  if [[ -n "${FilterList}" ]] ; then
    echo "-filter:v '${FilterList}'"
  fi

  return 0

}

function video_source_frame_rate {

  local SourceFrameRate

  SourceFrameRate="$(
    ffprobe \
      -v error \
      -select_streams v:${Stream} \
      -show_entries stream=r_frame_rate \
      -of default=noprint_wrappers=1:nokey=1 \
      "${CurrentFile}"
  )" || return 1

  if [[ -z "${SourceFrameRate}" ]] ; then
    err_error 'could not determine source frame rate'
    return 1
  fi

  echo "${SourceFrameRate}"

  return 0

}

function video_keyframe_interval {

  # Use an interval of 10 seconds for keyframes

  local KeyInt
  local SourceFrameRate
  local Stream

  Stream="$(video_stream_selector)" || return 1

  SourceFrameRate="$(video_source_frame_rate)"

  KeyInt=$(( ${SourceFrameRate} * 10 ))

  if [[ ! ${KeyInt} -gt ${SourceFrameRate} ]] ; then
    err_error 'could not determine keyframe interval'
    return 1
  fi

  echo "${KeyInt}"

  return 0

}

function video_min_keyframe_interval {

  # Use 1 keyframe per 20fps, e.g. 60fps = 3

  local KeyFrames
  local MinKeyInt
  local SourceFrameRate
  local SourceFrameRateRounded
  local Stream

  Stream="$(video_stream_selector)" || return 1

  SourceFrameRate="$(video_source_frame_rate)"

  # Rounds SourceFrameRate to the nearest whole number
  SourceFrameRateRounded=$(
    printf %.0f $(
      echo ${SourceFrameRate} |
      bc -l
    )
  )

  # Make sure we end up with at least 1 keyframe
  if [[ ${SourceFrameRateRounded} -lt 20 ]] ; then
    SourceFrameRateRounded=20
  fi

  KeyFrames=$(( ${SourceFrameRateRounded} / 20 ))

  if [[ ${KeyFrames} -ge 1 ]] ; then
    MinKeyInt=$(( ${SourceFrameRate} / ${KeyFrames} ))
  else
    err_error 'could not determine key frame interval'
    return 1
  fi

  echo "${MinKeyInt}"

  return 0

}

function video_motion_estimation_range {

  # Equivalent to 2 seconds of video

  local MeRange
  local SourceFrameRate

  SourceFrameRate="$(video_source_frame_rate)"

  MeRange="$(( ${SourceFrameRate} * 2 ))"

  if [[ -z "${MeRange}" ]] ; then
    err_error 'could not determine motion estimation range'
    return 1
  fi

  echo "${MeRange}"

  return 0

}

function video_codec_x264_params {

  # Generates formatted ffmpeg x264-params key/values

  err_error 'x264 not implemented'

  return 1

  local Parameters

  Parameters=(
    # Frame-type opions
    'keyint'
    'min-keyint'
    'scenecut'
    'pre-scenecut'
    'bframes'
    'no-b-adapt'
    'b-adapt'
    'b-bias'
    'b-pyramid'
    'no-cabac'
    'ref'
    'no-deblock'
    'deblock'
    'interlaced'
    # Ratecontrol
    'qp'
    'bitrate'
    'crf'
    'vbv-maxrate'
    'vbv-bufsize'
    'vbv-init'
    'qpmin'
    'qpmax'
    'qpstep'
    'ratetol'
    'ipratio'
    'pbratio'
    'chroma-qp-offset'
    'aq-mode'
    'aq-strength'
    'pass'
    'stats'
    'rceq'
    'qcomp'
    'cplxblur'
    'qblur'
    'zones'
    'qpfile'
    # Analysis
    # Input/Output
  )

}

function video_codec_x265_params {

  # Generates formatted ffmpeg x265-params key/values

  local Param
  local Parameters
  local ParamHasValue
  local ParamList

  Parameters=(
    'log-level=2' # FIXME
    "frame-threads=$(( $(cpu_physical) / 2 ))" # FIXME
    "pools=$(cpu_logical)" # FIXME
    #numa-pools                # char
    'wpp=1' # FIXME
    'pmode=0'                  # bool
    'pme=0'                    # bool
    #fps                       # float/int/fraction
    'interlace=0'
    #'level-idc'               # int/flost
    #'high-tier'               # bool
    'ref=6' # <=6 due to b-frames & b-pyramid
    'allow-non-conformance=0'
    'rd=5'
    'ctu=64'
    'min-cu-size=8'
    #'limit-refs'              # int
    'limit-modes=0'
    'rect=0'
    'amp=0'
    'early-skip=0'
    'fast-intra=0'
    'b-intra=1'
    'cu-lossless=0'
    'tskip-fast=0'
    #'rd-refine=1' # bool
    'rdoq-level=1'          # int
    'tu-intra-depth=4'         # int
    'tu-inter-depth=4'         # int
    'nr-intra=0'            # int
    'nr-inter=0'            # int
    'tskip=0'
    'rdpenalty=0'           # int
    'max-tu-size=32'
    'max-merge=5'              # int
    'me=3'
    'subme=5'                  # int
    "merange=$(video_motion_estimation_range)"
    'temporal-mvp=1'            # bool
    'weightp=1'
    'weightb=1'
    'strong-intra-smoothing=0'
    'constrained-intra=0'
    #'psy-rd=0.3' # < 0.9
    #'psy-rdoq=4.0' # > 3 & < 5
    'open-gop=1'                # bool
    "keyint=$(video_keyframe_interval)"
    "min-keyint=$(video_min_keyframe_interval)"
    'scenecut=40'                # int
    #'intera-refresh'          # bool
    'rc-lookahead=60'          # int (> bframes & < 250)
    'lookahead-slices=0'        # int
    'b-adapt=2'
    'bframes=3'
    'bframe-bias=0'
    'b-pyramid=1'
    #'bitrate'                 # int
    'vbv-bufsize=31250'        # int
    'vbv-maxrate=31250'        # int
    'vbv-init=0.9'             # float
    'lossless=0'
    'aq-mode=0' # something with aq is causing crashes on 2nd pass encodes
    'aq-strength=0' # maybe the crash is caused by aq-strength >2.0
    #'qg-size'                 # int
    'cutree=0'
    'strict-cbr=0'
    'cbqpoffs=0'              # int
    'crqpoffs=0'              # int
    'ipratio=1.4'                 # float
    'pbratio=1.3'                 # float
    'qcomp=0.6' # values < 0.5 segfault, only ever use 0.6, > values blur
    #'qpstep=4'
    #'qblur=0.8'
    #'cplxblur=10.0' # <=20
    #'zones'
    #'signhide'                # bool
    #'qpfile'                  # char
    #'scaling-list'            # char
    #'lambda-file'             # char
    #'deblock=1\\:1'
    #'sao=1'
    #'sao-non-deblock=1'
    #'sar'
    #'display-window'
    #'overscan'
    #'videoformat'
    #'range'
    #'colorprim'
    #'transfer'
    #'colormatrix'
    #'chromaloc'
    #'master-display'
    #'max-cll'
    #'min-luma'
    #'max-luma'
    #'annexb'
    #'repeat-headers'
    #'aud'
    #'hrd'
    #'info'
    #'hash=2'
    #'temporal-layers'
  )

  if [[ ${ARKIVE_VIDEO_ENCODING_PASSES} > 1 ]] ; then
    Parameters+=(
      "pass=${Pass}"
      'slow-firstpass=0'
      "stats=${TMP}/${CurrentFileBase}.stats"
      "analysis-file=${TMP}/${CurrentFileBase}.analysis"
    )
    TMP_FILES+=(
      "${TMP}/${CurrentFileBase}.stats"
      "${TMP}/${CurrentFileBase}.analysis"
    )
    # Determine analysis-mode
    if [[ ${Pass} -eq 1 ]] ; then
      Parameters+=('analysis-mode=1')
    else
      Parameters+=('analysis-mode=2')
    fi
  else
    Parameters+=('analysis-mode=0')
  fi

  ParamList=
  for Param in ${Parameters[@]} ; do
    # FFmpeg's key/value parser can't handle null values, make
    # sure a value is set.
    ParamHasValue="$(echo "${Param}" | awk -F '=' '{ print $2 ; exit }')"
    if [[ -z "${ParamHasValue}" ]] ; then
      err_error "malformed key/value: ${Param}"
      return 1
    fi
    ParamList="${ParamList}${ParamList:+:}${Param}"
  done

  echo "-x265-params '${ParamList}'"

  return 0

}

function video_codec_vp9_params {

  err_error 'vp9 not implemented'

  return 1

}

function video_codec_vp10_params {

  err_error 'vp10 not implemented'

  return 1

}

function video_codec {

  # codec and codec parameters

  local CodecString

  case "${ARKIVE_VIDEO_CODEC}" in
    'h264')
      err_error 'h264 support not implemented'
      return 1
      CodecString="-c:v libx264 $(video_codec_x264_params)" || return 1
      ;;
    'h265')
      CodecString="-c:v libx265 $(video_codec_x265_params)" || return 1
      ;;
    'vp9')
      err_error 'vp9 support not implemented'
      return 1
      CodecString='-c:v libvpx-vp9'
      ;;
    'vp10')
      # vp10 is still in development
      err_error 'ffmpeg does not support vp10 yet'
      return 1
      CodecString='-c:v libvpx-vp10'
      ;;
    *)
      err_error "invalid video codec: ${ARKIVE_VIDEO_CODEC}"
      return 1
      ;;
  esac

  echo "${CodecString}"

  return 0

}

function video_bitrate {

  # TODO: Calclate bitrate based off, bpp from cropped WIDTHxHEIGHT

  echo "-b:v 2048k"

  return 0

}

function video_pixel_format {

  local BitDepth
  local ChromaSubsampling
  local Endian
  local Experimental

  BitDepth="${ARKIVE_VIDEO_BIT_DEPTH}"
  ChromaSubsampling="${ARKIVE_VIDEO_CHROMA_SUBSAMPLING}"

  if [[ ! ${ARKIVE_VIDEO_CHROMA_SUBSAMPLING} == (420|422|444) ]] ; then
    err_error "invalid chroma subsampling: ${ARKIVE_VIDEO_CHROMA_SUBSAMPLING}"
    return 1
  fi

  if [[ ${ARKIVE_VIDEO_BIT_DEPTH} == (10|12) ]] ; then
    Endian='le'
  elif [[ ${ARKIVE_VIDEO_BIT_DEPTH} -eq 8 ]] ; then
    unset Endian
  else
    err_error "unsupported bit depth: ${BitDepth}"
    return 1
  fi

  if [[ ${ARKIVE_VIDEO_BIT_DEPTH} -eq 8 ]] ; then
    unset BitDepth
  fi

  # TODO: move -strict flag out of this function
  if [[ ${ARKIVE_VIDEO_CHROMA_SUBSAMPLING} > 422 ]] ; then
    Experimental=' -strict experimental'
  else
    unset Experimental
  fi

  echo "-pix_fmt yuv${ChromaSubsampling}p${BitDepth}${Endian}${Experimental}"

  return 0

}

function video_args {

  local VideoFilters
  local VideoBitrate
  local VideoCodec
  local VideoPixelFormat

  VideoFilters="$(video_filters)" || return 1
  VideoBitrate="$(video_bitrate)" || return 1
  VideoCodec="$(video_codec)" || return 1
  VideoPixelFormat="$(video_pixel_format)" || return 1

  echo "${VideoBitrate} ${VideoCodec} ${VideoFilters} ${VideoPixelFormat}"

  return 0

}

function tmp_cleanup {

  local File

  for File in "${TMP_FILES[@]}" ; do
    if [[ -f "${File}" ]] ; then
      rm -f "${File}"
    fi
  done

  # Remove tmp directory if we specified one
  if [[ "${TMP}" != "${OUT}" ]] ; then
    if [[ -d "${TMP}" ]] ; then
      # Add check for files not created before removing directory
      echo
    fi
  fi

  return 0

}

function run_arkive {

  local CurrentFile
  local CurrentFileBase
  local Pass
  local PassArgs

  local Audio
  local Subtitle
  local Chapter
  local Video
  local Metadata
  local OutputFile

  CurrentFile="${@}"
  CurrentFileBase="$(filename_formatted_base "${CurrentFile}")"

  # Initial pass number, DO NOT CHANGE VALUE
  Pass=1

  if [[ ! -f "${CurrentFile}" ]] ; then
    err_error "file does not exist: ${CurrentFile}"
    return 1
  fi

  #Subtitle="$(subtitle_args || return 1)"

  #Chapter="$(chapter_args || return 1)"

  Audio="$(audio_args)" || return 1

  OutputFile="${OUT}/${CurrentFileBase}.${ARKIVE_CONTAINER}" || return 1

  # Metadata
  #Metadata="$(metadata_args || return 1)"

  while [[ ${Pass} -le ${ARKIVE_VIDEO_ENCODING_PASSES} ]] ; do
    Video="$(video_args)" || return 1
    if [[ ${ARKIVE_VIDEO_ENCODING_PASSES} > 1 ]] ; then
      PassArgs="-pass ${Pass} -passlogfile ${TMP}/${CurrentFileBase}.ffmpeg-passlog"
      # TODO: add to tmp files array
    else
      PassArgs=''
    fi
    eval "ffmpeg \
            -y \
            -nostdin \
            -hide_banner \
            -stats \
            -loglevel info \
            -i \"${CurrentFile}\" \
            -threads 1 \
            ${PassArgs} \
            ${Video} \
            ${Audio} \
            ${OutputFile}" || return 1
    Pass=$(( ${Pass} + 1 ))
  done

  return 0

}

# Begin execution

requires || exit 1

input_parser $@ || exit 1

CPU_CORES=$(cpu_physical)
CPU_THREADS=$(cpu_logical)

OUT=$(output_directory)
TMP="$(tmp_directory)"

for FILE in "${INPUT_FILES[@]}" ; do
  run_arkive "${FILE}" || {
    err_warn "failed to process: ${FILE}" 'run_arkive'
  }
done

exit 0
