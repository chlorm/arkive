#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended[aac,fdk,mp3,opus]
##      mediainfo
##      awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

## Items to handle
# Video Stream
# Audio Stream
# Subtitles (english only, figure out how to determine which is english if not titled)
# Coverart??????????
# Metadata???????
# Chapterlist

## Source
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

noColors=0

## [valid file extensions to except]
export exts=(3gp avi flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## [version is incremented when file is updated]
VERSION=1

function current_dir {
	## [sets current directory as working directory]
	workDir=$( pwd )
	echo "Working Directory: \$workDir"
}

## TODO: auto detect if terminal supports color
function colors {
	if [ "${noColors}" -eq 0 ]; then
		colorR="\033[31m" # Red
		colorG="\033[32m" # Green
		colorP="\033[35m" # Purple
		colorB="\033[36m" # Cyan (light blue)
		colorD="\033[0m"  # default
	else
		unset colorR colorG colorP colorB colorD
	fi
}

## TODO: update help informaton and fix colors
function usage {
	HELP="\${cG}ARKhive version: ${VERSION}
Automates encoding video to ARK's archive format.

Usage: \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}FILE\$cZ [\${cU}OPTIONS\$cZ]\$cZ
       \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}DIR\$cZ  [\${cU}OPTIONS\$cZ]\$cZ
         \$colorG-o \${cU}DIRECTORY\$cZ        \$cR*\$cZ - set output directory (current is \$cP\${DIR}\$cZ)
         \$colorG-h\$cZ                    - print this message
         \$colorG-v\$cZ                    - print version"
}

current_dir
usage

## parse arguments
## options (-v/--version)(-h/--help)(-i/--input)(-o/--output)
while [ "$1" ]; do
	case "$1" in
		-o)			 DIR=$2; shift;;
		-h|--help|-help) eval "$msg \"${HELP}\""; exit 0;;
		-v|--version)
			$msg "ARKhive version: ${VERSION}\n\n";
			exit 0;;
		-*) eval "$msg \"${HELP}\""; emsg "\nUnknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "$msg \"${HELP}\""
				emsg "\nUnknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				emsg "Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done

function out_filename {
## [parse input file and create output filename according to ARK specification]
	# Television: %title%_S%season#%E%episode#%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bit_depth%.%samplerate%.%ext%
	# Movie: %title%_%year%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bitdepth%.%samlerate%.%ext%
	#outputFile=$(cat $inputFile | )
}

function cpu_detect {
	## [find number of physical cpu cores]
	cpuCores=$(\
		cat /proc/cpuinfo | \
		awk '/^cpu\ cores/{print $4}' | \
		tail -1)
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
	echo "Found CPU details..."
	echo "Cores: $cpuCores Threads: $cpuThreads"
}

function crop_detect {
	## Crop Black Bars [several checks to get accurate crop]
    CROP="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		CROP[$A]=$(\
			ffmpeg -i $workDir/$inputFile -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${CROP[$B]}" == "${CROP[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            GREATEST="$D"
        fi
    done
    ## [final crop value]
    CROP="${CROP[$GREATEST]}"
	## [frame width from final crop value]
    cropWidth=$(echo $CROP | awk -F ":" '{print $1}')
    echo "Crop detection complete"
}

function audio_config {
	## [finds first english audio stream]
	audioEngStream=$(\
		ffmpeg -i /home/jackal/test3.mkv -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
	## [offset audio stream by one for ffprobe because it counts from zero]
	audioChnStream=$(( $audioEngStream - 1 ))
	## [find number of audio channels]
	audioChannels=$(\
		ffprobe test3.mkv -show_streams -select_streams a:$audioChnStream 2>&1 | \
		awk -F "=" '/channels/ { print $2 }' | \
		tail -1)
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	## [set samplerate based on number of channels]
	if ["${audioChannels}" -gt 4 ] ; then
		audioSamRate="48000"
	else
		audioSamRate="44100"
	fi
	echo "Audio configuration complete:"
	echo "Channels: \$audioChannels Bitrate: \$audioBitrate Samplerate: \$audioSamRate"
}

function sub_titles {
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i /home/jackal/test3.mkv -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
}

## TODO: everything
function meta_data {
	## add language to streams
	## add title to video
}

## TODO: multi-pass while loop
## TODO: figure out multi-pass ffmpeg vs. x265 [does ffpeg -pass even work with libx265]
## TODO: multi-pass log
function ark_encode {
	## function calls
	out_filename
	audio_config
	cpu_detect
	crop_detect
	sub_titles
	meta_data
	ark_encode
	cleanup

	passes="2"
	PASS=1
	while [ "$PASS" -le "$passes" ] ; do

		ffmpeg -threads $cpuThreads -i $inputFile \
		-pass $PASS \
		-passlogfile "\$workDir/\$outputFile.ffmpass" \
		-c:v libx265 -b:v 1024k -minrate 1k -maxrate 32k -r 24000/1001 \
		-vf "crop=\$crop,scale=\$cropWidth:trunc(ow/a/2)*2" \
		-c:a libopus \
		-ac $audioChannels \
		-ab $audioBitrate \
		-ar $audioSamRate \
		-x265-params "\
		threads=\$cpuCores:frame-threads=\$cpuCores:\
		frames=0:\
		wpp:ctu=64:tu-intra-depth=4:tu-inter-depth=4:\
		me=2:subme=7:merange=60:max-merge=5:\
		b-intra:no-tskip:no-constrained-intra:\
		rect:amp:no-early-skip:weightp:weightb:\
		psy-rd=0.15:\
		keyint=250:min-keyint=23:rc-lookahead=60:b-adapt=2:bframes=3:bframe-bias=0:b-pyramid:ref=4:\
		vbv-bufsize=31250:vbv-maxrate=31250:vbv-init=0.9:aq-mode=0:no-cutree:cbqpoffs=3:crqpoffs=3:\
		pass=\$PASS:no-slow-firstpass:\
		lft:sao-lcu-opt=1:\
		hash=2"\
		-y "\$workDir/\$outputFile.mkv"

		PASS=$(( $PASS + 1 ))
	done
	echo "Encoding complete"
}

## TODO: remove multipass logs
function cleanup {
	# $workDir/$outFile.ffpass $workDir/$outFile.xpass
	if [ "${PASS}" == "${passes}" ] ; then
		## rm stats.file
	else
		## do nothing
	fi
}

## function calls
ark_encode
## TODO: finish this section