#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended:[aac,fdk,mp3,opus]
##      ffprobe
##      mkvtoolnix[mkvextract,mkvmerge]
##      Obviously: awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

## IDEAS
#> Coverart
#> Remove Logos
# https://www.ffmpeg.org/ffmpeg-filters.html#removelogo
# http://superuser.com/questions/683643/how-to-add-my-logo-for-the-first-30-seconds-in-a-video-with-ffmpeg
#> De-Interlace
# detect for interlaced content and de-interlace
#> File Counter x of # of files processed

## Example application
# https://github.com/macmichael01/ffmpeg-basher/blob/master/ffmpeg.sh

## Bash Portability
# http://wiki.bash-hackers.org/scripting/nonportable

## cut command
# http://www.computerhope.com/unix/ucut.htm

## Shelly - Shell scripts in haskell
# http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts

# http://en.wikipedia.org/wiki/ISO_base_media_file_format

## Source
# https://github.com/z1lt0id/encoder/blob/master/encode-tv
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

VERSION=1
allowedExtensions=(avi f4v flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## TODO: only enabled color it terminal supports it
## [add colors once finished]
colorR="\033[1;31m" # Red
colorG="\033[1;32m" # Green
colorP="\033[1;35m" # Purple
colorB="\033[0;36m" # Cyan (light blue)
colorY="\033[0;33m" # Yellow
colorU="\033[0;4m" # Yellow
colorD="\033[0;0m"  # default

## TODO: update help informaton and fix colors
function usage {
	HELP="\n\${colorP}ARKhive version:\${colorG} ${VERSION}
\${colorP}Automates encoding video to ARK's archive format.

Usage: \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}FILE\$colorD [\${colorU}OPTIONS\$colorD]\$colorD
       \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}DIR\$colorD  [\${colorU}OPTIONS\$colorD]\$colorD
         \$colorB-i \${colorU}FILE/DIRECTORY\$colorD   \$colorY*\$colorD - set input file\$colorD
         \$colorB-o \${colorU}DIRECTORY\$colorD          - set output directory (current is \$cP\${DIR}\$colorD)
         \$colorB-t \${colorU}DIRECTORY\$colorD          - set temp directory (current is \$cP\${DIR}\$colorD)
         \$colorB-h\$colorD                    - print this message
         \$colorB-v\$colorD                    - print version\n\n"
}

## [function call]
usage

## TODO: rewrite input to check against allowedExtensions array for reusability instead of explicitly defining
# http://hacktux.com/bash/arrays
if [ -z "$1" ];then echo -e "${colorR}ERROR: No arguments provided";exit 0;else
## [parse arguments]
while [ "$1" ]; do
	case "$1" in
		-i|--input)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No input provided"; exit 0;
			elif [ -f "$2" ]; then
				inputFileExt=${2##*.}
				case "$inputFileExt" in
					avi|f4v|flv|m2ts|m4v|mkv|mp4|mpeg|mpg|mov|ts|wmv)
				   		userInput=$2;shift;;
				   	*)
						echo "ERROR: Selected file's extension is not an allowed type!";
						echo "Allowed file types are: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv";
						exit 0;;
				esac
				shift
			else echo "ERROR: Input is not a file";exit 0;fi;;
		-o|--output)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output directory provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Output is not a directory";exit 0;
			else userOutput=$2;shift;fi;;
		-t|--temp)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Temp is not a directory";exit 0;
			else userTemp=$2; shift;fi;;
		-h|--help) eval "printf \"${HELP}\""; exit 0;;
		-v|--version)
			printf "ARKhive version: ${VERSION}\n\n";exit 0;;
		-*) eval "printf \"${HELP}\""; printf "\nERROR: Unknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "printf \"${HELP}\""
				printf "\nERROR: Unknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				printf "ERROR: Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done;fi

function parse_input {
	## [input file directory]
	cd $(dirname $userInput)
	inputFilePath=$(pwd)
	## [input filename w/ ext]
	fileName=${userInput##*/}
	## [input filename w/o ext]
	fileName=${fileName%%.*}
	## [add tag]
	arkMark="-ARK"
	fileName=$fileName$arkMark
	echo "Filename : $fileName"
	echo "Directory: $inputFilePath"
	echo "Extension: $inputFileExt"
}

function cpu_detect {
	## [cpu cores]
	cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu cores";exit 0;fi
	## [cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu threads";exit 0;fi
	echo "            Cores: $cpuCores Threads: $cpuThreads"
}

## TODO: rewrite to use x265 instead of ffmpeg and rewrite second instance for ffmpeg audio
## [progress indicator]
#function example_progress_counter {
#    START=$(date +%s); frameCounter=0; ETA=0; elapsedTime=0
#    ## [check to see if ffmpeg is running]
#    while [ -e /proc/$PID ]; do
#        sleep 2
#        ## [parse vstats file]
#        VSTATS=$(awk '{gsub(/frame=/, "")}/./{line=$1-1} END{print line}' \
#        	$HOME/vstats)
#        if [[ $VSTATS -gt $frameCounter ]]; then
#            frameCounter=$VSTATS
#            ## [progress-bar calc]
#            percentageCounter=$(( 100 * frameCounter / totalFrames ))
#            elapsedTime=$(( $(date +%s) - START )); echo $elapsedTime > $HOME/elapsed.value
#            ## [etc clac]
#            ETA=$(date -d @$(awk 'BEGIN{print int(('$elapsedTime' / '$frameCounter') *\
#            ('$totalFrames' - '$frameCounter'))}') -u +%H:%M:%S)
#        fi
#        ## [format for stats output]
#        echo -ne "\rFrame:$frameCounter of $totalFrames Time:$(date -d @$elapsedTime -u +%H:%M:%S) ETA:$ETA Percent:$percentageCounter"
#   done
#}

## [audio encoding progress]
#function audio_progress {
#	echo "incomplete"
#}

## [audio encoding progress]
#function video_progress {
#	echo "incomplete"
#}

## [subtitle stream selector]
## TODO: case for subtitle without language set
## TODO: handle videos without subtitles
# if no subtitles exist, skip this step
# elif eng exists do ... check for >1 eng, if so compare results further
# elif ... check und options for english ... find best result
# else ERROR: ....
function sub_titles {
	## use something like cpuThreads, if greater than 0 then continue, else file has no subtitles
	## http://en.wikibooks.org/wiki/FFMPEG_An_Intermediate_Guide/subtitle_options
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i $userInput -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
	echo "does nothing"
	#ffmpeg -i $userInput $outputFile.srt
}

function chapter_list {
	## [find chapters if any]
	hasChapters=$(\
		ffprobe $userInput 2>&1 | \
		awk '/Chapter/ { print $2 }' | \
		tail -1)
	## [no chapters were found]
	if [ -z "$hasChapters" ]; then
		## [set $hasChapters for muxing]
		hasChapters="0"
		echo "           input has no chapters"
	## [chapters were found]
	else
		## [set $hasChapters for muxing]
		hasChapters="1"
		mkvextract chapters --simple $userInput --redirect-output $inputFilePath/$fileName.xml
		echo "exported chapters"
	fi
}

## TODO: find if source contains metadata and depending on feild map export to file
function meta_data {
	## TODO: set creation date
	## http://multimedia.cx/eggs/supplying-ffmpeg-with-metadata/
	## http://jonhall.info/how_to/dump_and_load_metadata_with_ffmpeg
	## add language to streams
	## add title to video
	echo "        metadata doesn't work yet"
}

## [audio stream selection and configuration]
## TODO: audioEngStream only detects mkv english stream, adapt for other formats (m2ts)
## TODO: mkv audio needs to be tested with more possible exceptions (not tested with und audio streams)
## TODO: this section (and subtitles) should contain the most logic to find
## 		 correct streams consistently, should account for all allowed container formats
function config_audio {
	## Contaier Formats: avi flv/f4v m2ts mpeg mkv mov mp4/m4v ts wmv
	## [find audio stream to use]
	if [ -z "$inputFileExt" ]; then echo "ERROR: could not find file extension";exit 0;
	elif [ $inputFileExt == "mkv" ]; then
		## [finds first english audio stream]
		audioEngStream=$(\
			ffmpeg -i $userInput -f null - 2>&1 | \
			grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
			awk -F ":" '{print $2}' | \
			tail -1)
		if [ -z "$audioEngStream" ];then $audioEngStream="2";fi
		## [offset audio stream by one for ffprobe because it counts from zero]
		audioChnStream=$(( $audioEngStream - 1 ))
		## [find number of audio channels]
		audioChannels=$(\
			ffprobe $userInput -show_streams -select_streams a:$audioChnStream 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	else
		## [assume audio stream number is 1]
		audioEngStream="1"
		## [find number of audio channels]
		## <select_stream does not seem to work with mp4 container>
		audioChannels=$(\
			ffprobe $userInput -show_streams 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	fi
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
	echo "    Stream: $audioEngStream Channels: $audioChannels Bitrate: $audioBitrate"
}

#function interlace_detect {
#}

function crop_detect {
	cpu_detect >/dev/null
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $userInput -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo "       crop detect $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "        Crop: $crop"
}

## [function calls]
stepTotal="10"
echo -e "${colorG}1 of $stepTotal${colorB}.........................${colorP}Parse Input${colorD}"
parse_input
echo -e "${colorG}2 of $stepTotal${colorB}................................${colorP}CPUs${colorD}"
cpu_detect
echo -e "${colorG}2 of $stepTotal${colorB}........................${colorP}Chapter List${colorD}"
chapter_list
echo -e "${colorG}3 of $stepTotal${colorB}...........................${colorP}Subtitles${colorD}"
echo "Subtitles currently aren't mapped to output"
sub_titles
echo -e "${colorG}4 of $stepTotal${colorB}......................${colorP}TODO: Metadata${colorD}"
meta_data
echo -e "${colorG}5 of $stepTotal${colorB}...................${colorP}Configuring Audio${colorD}"
config_audio
#echo -e "${colorG}5 of $stepTotal${colorB}........................${colorP}De-Interlace${colorD}"
#interlace_detect
echo -e "${colorG}6 of $stepTotal${colorB}................................${colorP}Crop${colorD}"
echo -e "    ${colorY}WARNING: This step may take a while${colorD}"
crop_detect
echo -e "${colorG}7 of $stepTotal${colorB}......................${colorP}Encoding Audio${colorD}"
echo "encoding audio"
	ffmpeg \
	-i "$userInput" \
	-c:a libopus \
	-map 0:$audioEngStream \
	-ac $audioChannels \
	-b:a $audioBitrate \
	-vbr on \
	-ar 48000 \
	-compression_level 10 \
	-y $inputFilePath/$fileName.opus || \
	{ echo -e "${colorR}ERROR: audio failed to encode"; exit 0; }
echo "audio complete"

## [get duration and fps then calculate total frames]
FPS="23.976023976"
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
if [ -z "$totalFrames" ];then echo -e "${colorR}ERROR: Cound not calculate total frames";exit 0;fi

echo -e "${colorG}8 of $stepTotal${colorB}......................${colorP}Encoding Video${colorD}"
## TODO: redirect ffmpeg output to a tmp file, name same as other files and remove after finished
## [number of encoding passes]
passes="2"
## [initial pass number, DO NOT CHANGE VALUE]
PASS=1
echo "total $totalFrames"
while [ $PASS -le $passes ]; do
	echo "Encoding Pass: $PASS"
	echo "total $totalFrames"
    ffmpeg \
    -threads $cpuThreads \
    -i "$userInput" \
    -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
    -r 24000/1001 \
    -pix_fmt yuv420p \
    -f yuv4mpegpipe - 2> nul | \
    x265 \
    --y4m \
    --stats=$inputFilePath/$fileName.stats \
    --threads=$cpuCores \
    --frame-threads=$cpuCores \
    --wpp \
    --ctu=64 \
    --no-cutree \
    --tu-intra-depth=4 \
    --tu-inter-depth=4 \
    --me=2 \
    --cbqpoffs=3 \
    --crqpoffs=3 \
    --psy-rd=0.15 \
    --subme=7 \
    --merange=60 \
    --ref=4 \
    --bframes=3 \
    --b-pyramid \
    --b-adapt=2 \
    --bframe-bias=0 \
    --b-intra \
    --weightb \
    --weightp \
    --bitrate=1024 \
    --vbv-init=0.9 \
    --vbv-bufsize=31250 \
    --vbv-maxrate=31250 \
    --no-slow-firstpass \
    --pass=$PASS \
    --keyint=250 \
    --min-keyint=23 \
    --rc-lookahead=60 \
    --no-constrained-intra \
    --aq-mode=0 \
    --lft \
    --sao-lcu-opt=1 \
    --cbqpoffs=-3 \
    --crqpoffs=-3 \
    --rect \
    --amp \
    --max-merge=5 \
    --no-early-skip \
    --no-tskip \
    --hash=2 \
    -f $totalFrames \
    -o "$inputFilePath/$fileName.hvc" - || \
    echo "ERROR: video encoding failed"

    ## [if pass one complete output message]
    if [ $PASS == 2 ]; then
    	echo
		echo "Encoding complete"
    else
    	echo
    fi

	## [increment pass count]
    PASS="$(( $PASS + 1 ))"
done

echo -e "${colorG}9 of $stepTotal${colorB}.........................${colorP}Mux Streams${colorD}"
echo -e "  ${colorY}WARNING: You are about to cross the streams${colorD}"
echo "         This section does nothing"
## TODO: decide between ffmpeg and mkvtoolniv [mkvmerge] for muxing finished files
## http://cfc.kizzx2.com/index.php/muxing-audio-and-video-with-ffmpeg/
## metadata if any to be added here
#	ffmpeg \
#	-i ## video \
#	-i ## audio \
#	-i ## subtitles (if any) \
#	-i ## chapter list (if any) \
#	-vcodec copy
#	-acodec copy
## TODO: account for possible change in fps that may offset audio, always set for 23.976 (24000/1001)
## TODO: make subtitles toggleable incase none exist

#? --title [metadata title]
#? --default-language [default everything to be labeled as english]
#? --chapters $fileName [read chapters from file]
## NOTE: since multiple audio or subtitle tracks aren't allowed set all streams except subtitle to default
mkvmerge \
## GLOBAL
-o $inputFilePath/$fileName \
--output-charset UTF-8 \
--ui-language eng \ ##[always set to english to force default]
## VIDEO
--default-track $num \ ##[set to default track and default position]
--forced-track \ ##[since its required anyways]
--track-name VIDEO-$fileName \ ##[filename inside mkv container of streams]
--language $language \ ##[if eng set to english; elif no eng set to lang provided; elif und > error]
--default-duration 1:24000/1001fps \ ##[nTrack ID:fps (prevents audio sync issues)]
--video-tracks \
$inputFilePath/$fileName.hvc \
## AUDIO
--default-track $num \ ##[set to default track and default position]
--forced-track \ ##[since its required anyways]
--track-name AUDIO-$fileName \ ##[filename inside mkv container of streams]
--language $language \ ##[if eng set to english; elif no eng set to lang provided; elif und > error]
--audio-tracks \
$inputFilePath/$fileName.opus \
## SUBTITLES
--track-name SUBTITLES-$fileName \ ##[filename inside mkv container of streams]
--language $language \ ##[if eng set to english; else error] ONLY ALLOW ENGLISH
--sub-charset \
--subtitle-tracks \
$inputFilePath/$fileName.srt \
## CHAPTERS
--default-track $num \ ##[set to default track and default position]
--forced-track \ ##[since its required anyways] ?? determine if forcing chapters causes issues with some players
--track-name CHAPTERS-$fileName \ ##[filename inside mkv container of streams]
--chapter-language $language \ ##[this will need some work to figure out if chapters have titles]
--chapter-charset $chaptersCharset \ ##[whatever ffmpeg outputs]
--chapters \
$inputFilePath/$fileName.xml


echo -e "${colorG}10 of $stepTotal${colorB}............................${colorP}Cleanup${colorD}"
## CLEANUP
## TODO: remove multipass logs
# $workDir/$outFile.ffpass $workDir/$outFile.xpass
if [ "$PASS" == "2" ] ; then
	echo "remove stats.file"
	## x265 stats file [outputFile.stats]
	## ffmpeg redirected output [nul]
	## hvc tmp video [outputFile.hvc]
	## opus tmp audio [oputFile.opus]
	## srt tmp subtitles [outputFiel.srt]
	## xml tmp chapterlist [outputFile.xml]
	rm $inputFilePath/$fileName.hvc
	rm $inputFilePath/$fileName.stats
	rm $inputFilePath/$fileName.opus
	# $fileName.nul
	# $fileName.xml
	# $fileName.srt
else
	echo "do nothing"
fi