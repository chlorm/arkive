#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended:[aac,fdk,mp3,opus]
##      ffprobe
##      mkvtoolnix
##      Obviously: awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

# Coverart?????????? TODO

## Source
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

## [valid file extensions to except]
#export exts=(avi f4v flv m2ts m4v mpeg mkv mov mp4 ts wmv)
#inFileExt=${inputFile##*.}

## [version is incremented when file is updated]
VERSION=1

function current_dir {
	## [sets current directory as working directory]
	workDir=$( pwd )
	echo "Working Directory: $workDir"
}

msg="printf"

function emsg {
	$msg "${cR}$1${cZ}"
}

function update_encargs {
	e="\${ENCARGS_${FORMAT}}"
	ENCARGS=`eval echo "$e"`
	ENCHELP=0
}

## TODO: only enabled color it terminal supports it
## [add colors once finished]
colorR="\033[31m" # Red
colorG="\033[1;32m" # Green
colorP="\033[1;35m" # Purple
colorB="\033[0;36m" # Cyan (light blue)
colorY="\033[0;33m" # Yellow
colorU="\033[0;4m" # Yellow
colorD="\033[0;0m"  # default

## TODO: update help informaton and fix colors
function usage {
	HELP="\n\${colorP}ARKhive version:\${colorG} ${VERSION}
\${colorP}Automates encoding video to ARK's archive format.

Usage: \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}FILE\$colorD [\${colorU}OPTIONS\$colorD]\$colorD
       \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}DIR\$colorD  [\${colorU}OPTIONS\$colorD]\$colorD
         \$colorB-i \${colorU}FILE/DIRECTORY\$colorD   \$colorY*\$colorD - set input file\$colorD
         \$colorB-o \${colorU}DIRECTORY\$colorD          - set output directory (current is \$cP\${DIR}\$colorD)
         \$colorB-t \${colorU}DIRECTORY\$colorD          - set temp directory (current is \$cP\${DIR}\$colorD)
         \$colorB-h\$colorD                    - print this message
         \$colorB-v\$colorD                    - print version\n\n"
}

update_encargs
usage

## [if no input exit with error]
if [ -z "$1" ];then echo "ERROR: No arguments provided";exit 0;else
## parse arguments
while [ "$1" ]; do
	case "$1" in
		-i|--input)
			if [ -z "$2" ];then echo "ERROR: No input provided"; exit 0;
			#elif [ ! -d "$2" || ! -f "$2" ]; then
				#echo "ERROR: input is not a directory";
				#exit 0
			else userInput=$2;shift;fi;;
		-o|--output)
			if [ -z "$2" ];then echo "ERROR: No output directory provided";exit 0;
			elif [ ! -d "$2" ];then echo "ERROR: Output is not a directory";exit 0;
			else userOutput=$2;shift;fi;;
		-t|--temp)
			if [ -z "$2" ];then echo "ERROR: No output provided";exit 0;
			elif [ ! -d "$2" ];then echo "ERROR: Temp is not a directory";exit 0;
			else userTemp=$2; shift;fi;;
		-h|--help) eval "$msg \"${HELP}\""; exit 0;;
		-v|--version)
			$msg "ARKhive version: ${VERSION}\n\n";exit 0;;
		-*) eval "$msg \"${HELP}\""; emsg "\nUnknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "$msg \"${HELP}\""
				emsg "\nUnknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				emsg "Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done;fi

## TEMPORARY
inputFile=$userInput

function out_filename {
## [parse input file and create output filename according to ARK specification]
	# Television: %title%_S%season#%E%episode#%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bit_depth%.%samplerate%.%ext%
	# Movie: %title%_%year%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bitdepth%.%samlerate%.%ext%
	#outputFile=$(cat $inputFile | )
	outputFile=$inputFile
}

## [cpu detection for encoders]
function cpu_detect {
	## [find number of physical cpu cores]
	cpuCores=$(\
		cat /proc/cpuinfo | \
		awk '/^cpu\ cores/{print $4}' | \
		tail -1)
	if [ -z "$cpuCores" ];then echo "ERROR: Could not find # of cpu cores";exit 0;fi
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo "ERROR: Could not find # of cpu threads";exit 0;fi
	echo "            Cores: $cpuCores Threads: $cpuThreads"
}

## [progress indicator]
function progress_counter {
    START=$(date +%s); frameCounter=0; ETA=0; elapsedTime=0
    ## [check to see if ffmpeg is running]
    while [ -e /proc/$PID ]; do
        sleep 2
        ## [parse vstats file]
        VSTATS=$(awk '{gsub(/frame=/, "")}/./{line=$1-1} END{print line}' \
        	$HOME/vstats)
        if [[ $VSTATS -gt $frameCounter ]]; then
            frameCounter=$VSTATS
            ## [progress-bar calc]
            percentageCounter=$(( 100 * frameCounter / totalFrames ))
            elapsedTime=$(( $(date +%s) - START )); echo $elapsedTime > $HOME/elapsed.value
            ## [etc clac]
            ETA=$(date -d @$(awk 'BEGIN{print int(('$elapsedTime' / '$frameCounter') *\
            ('$totalFrames' - '$frameCounter'))}') -u +%H:%M:%S)
        fi
        ## [format for stats output]
        echo -ne "\rFrame:$frameCounter of $totalFrames Time:$(date -d @$elapsedTime -u +%H:%M:%S) ETA:$ETA Percent:$percentageCounter"
   done
}

## [subtitle stream selector]
function sub_titles {
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i /home/jackal/test3.mkv -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
}

function chapter_list {
	## [finds first english subtitle stream]
	echo " TODO: section"
}

## TODO: everything
function meta_data {
	## add language to streams
	## add title to video
	echo "        metadata doesn't work yet"
}

## [audio stream selection and configuration]
## TODO: if audio stream ==0 after selection, set to 1
## TODO: audioEngStream only detects mkv english stream, adapt for other formats
## TODO: this section (and subtitles) should contain the most logic to find
## 		 correct streams consistently, should account for all container formats
function config_audio {
	## Contaier Formats: avi flv/f4v m2ts mpeg mkv mov mp4/m4v ts wmv
	## [find audio stream to use]
	inFileExt=${inputFile##*.} # move this to another section
	if [ $inFileExt == "mkv" ]; then
		## [finds first english audio stream]
		audioEngStream=$(\
			ffmpeg -i $workDir/$inputFile -f null - 2>&1 | \
			grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
			awk -F ":" '{print $2}' | \
			tail -1)
		if [ -z "$audioEngStream" ];then $audioEngStream="2";fi
		## [offset audio stream by one for ffprobe because it counts from zero]
		audioChnStream=$(( $audioEngStream - 1 ))
		## [find number of audio channels]
		audioChannels=$(\
			ffprobe $workDir/$inputFile -show_streams -select_streams a:$audioChnStream 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo "ERROR: Could not find # of audio channels";exit 0;fi
	else
		## [assume audio stream is 1]
		audioEngStream="1"
		## [find number of audio channels]
		## <select_stream does not seem to work with mp4 container>
		audioChannels=$(\
			ffprobe $workDir/$inputFile -show_streams 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo "ERROR: Could not find # of audio channels";exit 0;fi
	fi
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
	echo "    Stream: $audioEngStream Channels: $audioChannels Bitrate: $audioBitrate"
}

## [black-bar detection and cropping]
function crop_detect {
	cpu_detect >/dev/null
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $workDir/$inputFile -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo "       crop detect $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "        Crop: $crop"
}

## [function calls]
stepTotal="10"
echo -e "${colorG}1 of $stepTotal${colorB}............................${colorP}Filename${colorD}"
#current_dir
out_filename
echo -e "${colorG}2 of $stepTotal${colorB}................................${colorP}CPUs${colorD}"
cpu_detect
echo -e "${colorG}3 of $stepTotal${colorB}...........................${colorP}Subtitles${colorD}"
echo "Subtitles currently aren't mapped to output"
sub_titles
echo -e "${colorG}4 of $stepTotal${colorB}......................${colorP}TODO: Metadata${colorD}"
meta_data
echo -e "${colorG}5 of $stepTotal${colorB}...................${colorP}Configuring Audio${colorD}"
config_audio
echo -e "${colorG}6 of $stepTotal${colorB}................................${colorP}Crop${colorD}"
echo -e "    ${colorY}WARNING: This step may take a while${colorD}"
crop_detect
echo -e "${colorG}7 of $stepTotal${colorB}......................${colorP}Encoding Audio${colorD}"
echo "encoding audio"
	ffmpeg \
	-i "$inputFile" \
	-c:a libopus \
	-map 0:$audioEngStream \
	-ac $audioChannels \
	-b:a $audioBitrate \
	-vbr on \
	-ar 48000 \
	-compression_level 10 \
	-y $workDir/$outputFile.opus 2>/dev/null || \
	{ echo "ERROR: audio failed to encode"; exit 0; }
echo "audio complete"

## [get duration and fps then calculate total frames]
FPS=$(ffprobe "$userInput" 2>&1 | sed -n "s/.*, \(.*\) tbr.*/\1/p")
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
if [ -z "$totalFrames" ];then echo "ERROR: Cound not calculate total frames";exit 0;fi

echo -e "${colorG}8 of $stepTotal${colorB}......................${colorP}Encoding Video${colorD}"
## TODO: multi-pass log --stats=/path/file.log
## TODO: redirect ffmpeg output to a tmp file, name same as other files and remove after finished
## [number of encoding passes]
passes="2"
## [initial pass number, DO NOT CHANGE VALUE]
PASS=1
echo "total $totalFrames"
while [ $PASS -le $passes ]; do
	echo "Encoding Pass: $PASS"
    ffmpeg \
    -threads $cpuThreads \
    -i "$inputFile" \
    -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
    -r 24000/1001 \
    -pix_fmt yuv420p \
    -f yuv4mpegpipe - 2> nul | \
    x265 \
    --y4m \
    --threads=$cpuCores \
    --frame-threads=$cpuCores \
    --wpp \
    --ctu=64 \
    --no-cutree \
    --tu-intra-depth=4 \
    --tu-inter-depth=4 \
    --me=2 \
    --cbqpoffs=3 \
    --crqpoffs=3 \
    --psy-rd=0.15 \
    --subme=7 \
    --merange=60 \
    --ref=4 \
    --bframes=3 \
    --b-pyramid \
    --b-adapt=2 \
    --bframe-bias=0 \
    --b-intra \
    --weightb \
    --weightp \
    --bitrate=1024 \
    --vbv-init=0.9 \
    --vbv-bufsize=31250 \
    --vbv-maxrate=31250 \
    --no-slow-firstpass \
    --pass=$PASS \
    --keyint=250 \
    --min-keyint=23 \
    --rc-lookahead=60 \
    --no-constrained-intra \
    --aq-mode=0 \
    --lft \
    --sao-lcu-opt=1 \
    --cbqpoffs=-3 \
    --crqpoffs=-3 \
    --rect \
    --amp \
    --max-merge=5 \
    --no-early-skip \
    --no-tskip \
    --hash=2 \
    -f $totalFrames \
    -o "$workDir/$outputFile.hvc" - 

    ## [if pass one complete output message]
    if [ $PASS == 1 ]; then
    	echo "Pass 1 complete"
    elif [ $PASS == 2 ]; then
		echo "Encoding complete"
    else
    	echo "probably some kind of error"
    fi

    ## [the fps was orginally calculated from source, but the fps may]
    ## [have changed because fps from source is not used, recalculate]
	FPS="23.976023976"
	totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
	## [increment pass count]
    PASS="$(( $PASS + 1 ))"
done

echo -e "${colorG}9 of $stepTotal${colorB}.........................${colorP}Mux Streams${colorD}"
echo "  WARNING, You are about to cross the streams"
echo "         This section does nothing"
## metadata if any to be added here
#	ffmpeg \
#	-i ## video \
#	-i ## audio \
#	-i ## subtitles (if any) \
#	-i ## chapter list (if any) \
#	-vcodec copy
#	-acodec copy
#	$outputFile.mkv


echo -e "${colorG}10 of $stepTotal${colorB}............................${colorP}Cleanup${colorD}"
## CLEANUP
## TODO: remove multipass logs
	# $workDir/$outFile.ffpass $workDir/$outFile.xpass
	if [ "$PASS" == "$passes" ] ; then
		echo "remove stats.file"
		## x265 stats file
		## ffmpeg redirected output
		## hvc tmp video
		## opus tmp audio
		## srt tmp subtitles
		## xml tmp chapterlist
	else
		echo "do nothing"
	fi