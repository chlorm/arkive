#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended[aac,fdk,mp3,opus]
##      mediainfo
##      awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

# Coverart?????????? TODO

## Source
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

inputFile=$@

## [valid file extensions to except]
#export exts=(3gp avi flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## [version is incremented when file is updated]
#VERSION=1

function current_dir {
	## [sets current directory as working directory]
	workDir=$( pwd )
	echo "Working Directory: $workDir"
}

#	colorR="\033[31m" # Red
#	colorG="\033[32m" # Green
#	colorP="\033[35m" # Purple
#	colorB="\033[36m" # Cyan (light blue)
#	colorD="\033[0m"  # default

## TODO: update help informaton and fix colors
#function usage {
#	HELP="\${cG}ARKhive version: ${VERSION}
#Automates encoding video to ARK's archive format.
#
#Usage: \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}FILE\$cZ [\${cU}OPTIONS\$cZ]\$cZ
#       \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}DIR\$cZ  [\${cU}OPTIONS\$cZ]\$cZ
#         \$colorG-o \${cU}DIRECTORY\$cZ        \$cR*\$cZ - set output directory (current is \$cP\${DIR}\$cZ)
#         \$colorG-h\$cZ                    - print this message
#         \$colorG-v\$cZ                    - print version"
#}

#current_dir
#usage

## parse arguments
## options (-v/--version)(-h/--help)(-i/--input)(-o/--output)
#while [ "$1" ]; do
#	case "$1" in
#		-i|--input)			 DIR=$2; shift;;
#		-o|--output)			 DIR=$2; shift;;
#		-h|--help) eval "$msg \"${HELP}\""; exit 0;;
#		-v|--version)
#			$msg "ARKhive version: ${VERSION}\n\n";
#			exit 0;;
#		-*) eval "$msg \"${HELP}\""; emsg "\nUnknown option $1\n"; exit 1;;
#		*)
#			if [ -n "${INPATH}" ]; then
#				eval "$msg \"${HELP}\""
#				emsg "\nUnknown option $1\n"
#				exit 1
#			elif [ ! -r "$1" ]; then
#				emsg "Unable to read $1\n"
#				exit 2
#			else
#				INPATH="$1"
#			fi;;
#	esac
#	shift
#done

function out_filename {
## [parse input file and create output filename according to ARK specification]
	# Television: %title%_S%season#%E%episode#%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bit_depth%.%samplerate%.%ext%
	# Movie: %title%_%year%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bitdepth%.%samlerate%.%ext%
	#outputFile=$(cat $inputFile | )
	outputFile=$inputFile
}

## [cpu detection for encoders]
function cpu_detect {
	## [find number of physical cpu cores]
	cpuCores=$(\
		cat /proc/cpuinfo | \
		awk '/^cpu\ cores/{print $4}' | \
		tail -1)
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)

	echo "              Found CPU details"
	echo "             Cores: $cpuCores Threads: $cpuThreads"
}

## [ffmpeg progress indicator]
function progress_counter {
    START=$(date +%s); frameCounter=0; ETA=0; elapsedTime=0
    ## [check to see if ffmpeg is running]
    while [ -e /proc/$PID ]; do
        sleep 2
        ## [parse vstats file]
        VSTATS=$(awk '{gsub(/frame=/, "")}/./{line=$1-1} END{print line}' \
        $HOME/vstats)
        if [[ $VSTATS -gt $frameCounter ]]; then                # Parsed sane or no?
            frameCounter=$VSTATS
            ## [progress-bar calc]
            percentageCounter=$(( 100 * frameCounter / totalFrames ))
            elapsedTime=$(( $(date +%s) - START )); echo $elapsedTime > $HOME/elapsed.value
            ## [etc clac]
            ETA=$(date -d @$(awk 'BEGIN{print int(('$elapsedTime' / '$frameCounter') *\
            ('$totalFrames' - '$frameCounter'))}') -u +%H:%M:%S)
        fi
        ## [format for stats output]
        echo -ne "\rFrame:$frameCounter of $totalFrames Time:$(date -d @$elapsedTime -u +%H:%M:%S) ETA:$ETA Percent:$percentageCounter"
    done
}

## [subtitle stream selector]
function sub_titles {
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i /home/jackal/test3.mkv -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
}

function chapter_list {
	## [finds first english subtitle stream]
	echo " TODO: section"
}

## TODO: everything
function meta_data {
	## add language to streams
	## add title to video
	echo "        metadata doesn't work yet"
}

## [audio stream selection and configuration]
function config_audio {
	## [finds first english audio stream]
	audioEngStream=$(ffmpeg -i $workDir/$inputFile -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
	## [offset audio stream by one for ffprobe because it counts from zero]
	audioChnStream=$(( $audioEngStream - 1 ))
	## [find number of audio channels]
	audioChannels=$(ffprobe $workDir/$inputFile -show_streams -select_streams a:$audioChnStream 2>&1 | \
		awk -F "=" '/channels/ { print $2 }' | \
		tail -1)
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
}

## [black-bar detection and cropping]
function crop_detect {
	cpu_detect >/dev/null 2>&1
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $workDir/$inputFile -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo "        crop detect $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "Crop detection complete"
    echo "Crop: $crop"
}

## function calls
echo "1 of numVal............................Filename"
out_filename
echo "2 of numVal................................CPUs"
cpu_detect
echo "3 of numVal...........................Subtitles"
echo "  Subtitle currently aren't mapped to output"
sub_titles
echo "4 of numVal......................TODO: Metadata"
meta_data
echo "5 of numVal...................Configuring Audio"
config_audio
echo "6 of numVal................................Crop"
crop_detect


echo "7 of numVal......................Encoding Audio"
ffmpeg -i $inputFile -c:a libopus -map 0:$audioEngStream \
-ac $audioChannels -b:a $audioBitrate -vbr on -ar 48000 \
-compression_level 10 -y $workDir/$outputFile.opus 2>/dev/null &
PID=$! && 
echo "ffmpeg PID = $PID"
## [show progress]
progress_counter

## [get duration and fps then calculate total frames]
FPS=$(ffprobe "$1" 2>&1 | sed -n "s/.*, \(.*\) tbr.*/\1/p")
totalLength=$(ffprobe "$1" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
#if [ ! "$totalFrames" -gt "0" ]; then echo error; exit; fi

echo "8 of numVal......................Encoding Video"
## TODO: finish this section
## TODO: multi-pass while loop ???not sure if it works???
## TODO: figure out multi-pass ffmpeg vs. x265 [does ffpeg -pass even work with libx265]
## TODO: multi-pass log

passes="2"
PASS=1
while [ "$PASS" -le "$passes" ] ; do
    ffmpeg \
    -threads $cpuThreads \
    -i "$inputFile" \
    -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
    -r 24000/1001 \
    -pix_fmt yuv420p \
    -f yuv4mpegpipe - 2> nul | \
    x265 \
    --y4m \
    --threads=$cpuCores \
    --frame-threads=$cpuCores \
    --wpp \
    --ctu=64 \
    --no-cutree \
    --tu-intra-depth=4 \
    --tu-inter-depth=4 \
    --me=2 \
    --cbqpoffs=3 \
    --crqpoffs=3 \
    --psy-rd=0.15 \
    --subme=7 \
    --merange=60 \
    --ref=4 \
    --bframes=3 \
    --b-pyramid \
    --b-adapt=2 \
    --bframe-bias=0 \
    --b-intra \
    --weightb \
    --weightp \
    --bitrate=1024 \
    --vbv-init=0.9 \
    --vbv-bufsize=31250 \
    --vbv-maxrate=31250 \
    --no-slow-firstpass \
    --pass=$PASS \
    --keyint=250 \
    --min-keyint=23 \
    --rc-lookahead=60 \
    --no-constrained-intra \
    --aq-mode=0 \
    --lft \
    --sao-lcu-opt=1 \
    --cbqpoffs=-3 \
    --crqpoffs=-3 \
    --rect \
    --amp \
    --max-merge=5 \
    --no-early-skip \
    --no-tskip \
    --hash=2 \
    -f 0 \
    -o "$workDir/$outputFile.$container" - 2>/dev/null &
PID=$! && 
echo "ffmpeg PID = $PID"
## [show progress]
progress_counter

    ## [if pass one complete output message]

    PASS="$(( $PASS + 1 ))"
done
echo "Encoding complete"


echo "9 of numVal.............................Cleanup"
## CLEANUP
## TODO: remove multipass logs
	# $workDir/$outFile.ffpass $workDir/$outFile.xpass
	if [ "${PASS}" == "${passes}" ] ; then
		echo "rm stats.file"
	else
		echo "do nothing"
	fi