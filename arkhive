#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended:[aac,fdk,mp3,opus]
##      ffprobe
##      mkvtoolnix[mkvextract,mkvmerge]
##      Obviously: awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

VERSION=1
#allowedExtensions=(avi f4v flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## [colors]
colorR="\033[1;31m" # Red
colorG="\033[1;32m" # Green
colorP="\033[1;35m" # Purple
colorB="\033[0;36m" # Cyan (light blue)
colorY="\033[0;33m" # Yellow
colorU="\033[0;4m"  # Underline
colorD="\033[0;0m"  # default

function usage {
	HELP="\n\${colorP}ARKhive version:\${colorG} ${VERSION}
\${colorP}Automates encoding video to ARK's archive format.

Usage: \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}FILE\$colorD [\${colorU}OPTIONS\$colorD]\$colorD
         \$colorB-i \${colorU}FILE\$colorD             \$colorY*\$colorD - set input file\$colorD
         \$colorB-o \${colorU}DIRECTORY\$colorD          - set output directory (current is \$cP\${DIR}\$colorD)
         \$colorB-t \${colorU}DIRECTORY\$colorD          - set temp directory (current is \$cP\${DIR}\$colorD)
         \$colorB-h\$colorD                    - print this message
         \$colorB-v\$colorD                    - print version\n\n"
}

## [function call]
usage

## TODO: rewrite input to check against allowedExtensions array for reusability instead of explicitly defining
# http://hacktux.com/bash/arrays
if [ -z "$1" ];then echo -e "${colorR}ERROR: No arguments provided";exit 0;else
## [parse arguments]
while [ "$1" ]; do
	case "$1" in
		-i|--input)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No input provided"; exit 0;
			elif [ -f "$2" ]; then
				inputFileExt=${2##*.}
				case "$inputFileExt" in
					avi|f4v|flv|m2ts|m4v|mkv|mp4|mpeg|mpg|mov|ts|wmv)
				   		userInput=$2;shift;;
				   	*)
						echo "ERROR: Selected file's extension is not an allowed type!";
						echo "Allowed file types are: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv";
						exit 0;;
				esac
				shift
			else echo "ERROR: Input is not a file";exit 0;fi;;
		-o|--output)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output directory provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Output is not a directory";exit 0;
			else userOutput=$2;shift;fi;;
		-t|--temp)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Temp is not a directory";exit 0;
			else userTemp=$2; shift;fi;;
		-h|--help) eval "printf \"${HELP}\""; exit 0;;
		-v|--version)
			printf "ARKhive version: ${VERSION}\n\n";exit 0;;
		-*) eval "printf \"${HELP}\""; printf "\nERROR: Unknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "printf \"${HELP}\""
				printf "\nERROR: Unknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				printf "ERROR: Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done;fi

function parse_input {
	## [input file directory]
	cd $(dirname $userInput)
	inputFilePath=$(pwd)
	## [input filename w/ ext]
	fileName=${userInput##*/}
	## [input filename w/o ext]
	fileName=${fileName%%.*}
	## [add tag]
	arkMark="-ARK"
	fileName=$fileName$arkMark
	echo "         Filename : $fileName"
	echo "         Directory: $inputFilePath"
	echo "         Extension: $inputFileExt"
}

function cpu_detect {
	## [cpu cores]
	cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu cores";exit 0;fi
	## [cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu threads";exit 0;fi
	echo "            Cores: $cpuCores Threads: $cpuThreads"
}

## [subtitle stream selector]
## TODO: case for subtitle without language set
## TODO: actually export subtitles to be muxed later
## TODO: if .sub/.idx covert to .srt with VobSub2SRT
function sub_titles {
	## [find subtitles if any]
	hasSubtitles=$(\
		ffprobe $userInput 2>&1 | \
		awk '/Subtitle/ { print $2 }')
	## [no subtitles were found]
	if [ -z "$hasSubtitles" ]; then
		## [set $hasChapters for muxing]
		hasSubtitles="0"
		echo "           input has no subtitles"
	## [subtitles were found]
	else
		## [set $hasChapters for muxing]
		hasSubtitles="1"
		## [finds first english subtitle stream]
		subtitleStream=$(\
			ffmpeg -i $userInput -f null - 2>&1 | \
			grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
			awk -F ":" '{print $2}' | \
			tail -1)
		if [ -z "subtitleStream" ]; then
			echo "no english subtitles found"
		fi
		mkvextract tracks $userInput $subtitleStream:$fileName
		#subtitleType=$(mkvextract tracks $userInput $subtitleStream:$fileName | \
		#awk '/$fileName/{print $0}')
		# >/dev/null
		echo "    Found English Subtitles, Stream: $subtitleStream Format: $subtitleType"
	fi
}

function chapter_list {
	## [find chapters if any]
	hasChapters=$(\
		ffprobe $userInput 2>&1 | \
		awk '/Chapter/ { print $2 }')
	## [no chapters were found]
	if [ -z "$hasChapters" ]; then
		## [set $hasChapters for muxing]
		hasChapters="0"
		echo "             No Chapters Found"
	## [chapters were found]
	else
		## [set $hasChapters for muxing]
		hasChapters="1"
		mkvextract chapters --simple $userInput --redirect-output $inputFilePath/$fileName.xml
		echo "exported chapters"
	fi
}

## [audio stream selection and configuration]
## TODO: audioEngStream only detects mkv english stream, adapt for other formats (m2ts)
## TODO: mkv audio needs to be tested with more possible exceptions (not tested with und audio streams)
## TODO: this section (and subtitles) should contain the most logic to find
## 		 correct streams consistently, should account for all allowed container formats
function config_audio {
	## Contaier Formats: avi flv/f4v m2ts mpeg mkv mov mp4/m4v ts wmv
	## [find audio stream to use]
	if [ -z "$inputFileExt" ]; then echo "ERROR: could not find file extension";exit 0;
	elif [ $inputFileExt == "mkv" ]; then
		## [finds first english audio stream]
		audioEngStream=$(\
			ffmpeg -i $userInput -f null - 2>&1 | \
			grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
			awk -F ":" '{print $2}' | \
			tail -1)
		## [if no english audio then assume stream number 1 is audio]
		## TODO: this needs some work, may cause error with non-english videos by assuming there is always audio in stream 1
		if [ -z "$audioEngStream" ];then $audioEngStream="2";fi
		## [offset audio stream by one for ffprobe because it counts from zero]
		audioChnStream=$(( $audioEngStream - 1 ))
		## [find number of audio channels]
		audioChannels=$(\
			ffprobe $userInput -show_streams -select_streams a:$audioChnStream 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	else
		## [assume audio stream number is 1]
		audioEngStream="1"
		## [find number of audio channels]
		## <select_stream does not seem to work with mp4 container>
		audioChannels=$(\
			ffprobe $userInput -show_streams 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	fi
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
	echo "    Stream: $audioEngStream Channels: $audioChannels Bitrate: $audioBitrate"
}

function crop_detect {
	cpu_detect >/dev/null
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $userInput -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo -ne "\r       crop detect $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "        Crop: $crop"
}

## [function calls]
stepTotal="10"
echo -e "${colorG}1 of $stepTotal${colorB}.........................${colorP}Parse Input${colorD}"
parse_input
echo -e "${colorG}2 of $stepTotal${colorB}.................................${colorP}CPU${colorD}"
cpu_detect
echo -e "${colorG}3 of $stepTotal${colorB}............................${colorP}Chapters${colorD}"
chapter_list
echo -e "${colorG}4 of $stepTotal${colorB}...........................${colorP}Subtitles${colorD}"
sub_titles
echo -e "${colorG}5 of $stepTotal${colorB}...............................${colorP}Audio${colorD}"
config_audio
echo -e "${colorG}6 of $stepTotal${colorB}................................${colorP}Crop${colorD}"
echo -e "    ${colorY}WARNING: This step may take a while${colorD}"
crop_detect
echo -e "${colorG}7 of $stepTotal${colorB}......................${colorP}Encoding Audio${colorD}"
echo "encoding audio"
	ffmpeg \
	-i "$userInput" \
	-c:a libopus \
	-map 0:$audioEngStream \
	-ac $audioChannels \
	-b:a $audioBitrate \
	-vbr on \
	-ar 48000 \
	-compression_level 10 \
	-y $inputFilePath/$fileName.opus || \
	{ echo -e "${colorR}ERROR: audio failed to encode"; exit 0; }
echo "audio complete"

## [get duration and fps then calculate total frames]
FPS="23.976023976"
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
if [ -z "$totalFrames" ];then echo -e "${colorR}ERROR: Cound not calculate total frames";exit 0;fi

echo -e "${colorG}8 of $stepTotal${colorB}......................${colorP}Encoding Video${colorD}"

## [number of encoding passes]
passes="2"
## [initial pass number, DO NOT CHANGE VALUE]
PASS=1
while [ $PASS -le $passes ]; do
	echo "Encoding Pass: $PASS"
    ffmpeg \
    -threads $cpuThreads \
    -i "$userInput" \
    -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
    -r 24000/1001 \
    -pix_fmt yuv420p \
    -f yuv4mpegpipe - 2> nul | \
    x265 \
    --y4m \
    --stats=$inputFilePath/$fileName.stats \
    --threads=$cpuCores \
    --frame-threads=$cpuCores \
    --wpp \
    --ctu=64 \
    --no-cutree \
    --tu-intra-depth=4 \
    --tu-inter-depth=4 \
    --me=2 \
    --cbqpoffs=3 \
    --crqpoffs=3 \
    --psy-rd=0.15 \
    --subme=7 \
    --merange=60 \
    --ref=4 \
    --bframes=3 \
    --b-pyramid \
    --b-adapt=2 \
    --bframe-bias=0 \
    --b-intra \
    --weightb \
    --weightp \
    --bitrate=1024 \
    --vbv-init=0.9 \
    --vbv-bufsize=31250 \
    --vbv-maxrate=31250 \
    --no-slow-firstpass \
    --pass=$PASS \
    --keyint=250 \
    --min-keyint=23 \
    --rc-lookahead=60 \
    --no-constrained-intra \
    --aq-mode=0 \
    --lft \
    --sao-lcu-opt=1 \
    --cbqpoffs=-3 \
    --crqpoffs=-3 \
    --rect \
    --amp \
    --max-merge=5 \
    --no-early-skip \
    --no-tskip \
    --hash=2 \
    -f $totalFrames \
    -o "$inputFilePath/$fileName.hvc" - || \
    echo "ERROR: video encoding failed"

    ## [finished]
    if [ $PASS == $passes ]; then
    	echo
		echo "Encoding complete"
	## [not finised]
    else
    	echo
    fi

	## [increment pass count]
	PASS="$(( $PASS + 1 ))"
done

echo -e "${colorG}9 of $stepTotal${colorB}.........................${colorP}Mux Streams${colorD}"
echo -e "  ${colorY}WARNING: You are about to cross the streams${colorD}"
echo "         This section does nothing"
## TODO: decide between ffmpeg and mkvtoolniv [mkvmerge] for muxing finished files
## http://cfc.kizzx2.com/index.php/muxing-audio-and-video-with-ffmpeg/
## metadata if any to be added here
#	ffmpeg \
#	-i ## video \
#	-i ## audio \
#	-i ## subtitles (if any) \
#	-i ## chapter list (if any) \
#	-vcodec copy
#	-acodec copy
## TODO: account for possible change in fps that may offset audio, always set for 23.976 (24000/1001)
## TODO: make subtitles toggleable incase none exist

#? --title [metadata title]
#? --default-language [default everything to be labeled as english]
#? --chapters $fileName [read chapters from file]
## NOTE: since multiple audio or subtitle tracks aren't allowed set all streams except subtitle to default
if [ $hasChapters == 1 ]; then
	muxChapters="
		--default-track $num \ ##[set to default track and default position]
		--forced-track \ ##[since its required anyways] ?? determine if forcing chapters causes issues with some players
		--track-name CHAPTERS-$fileName \ ##[filename inside mkv container of streams]
		--chapter-language $language \ ##[this will need some work to figure out if chapters have titles]
		--chapter-charset $chaptersCharset \ ##[whatever ffmpeg outputs]
		--chapters \
		$inputFilePath/$fileName.xml"
elif [ $hasChapters == 0 ]; then
	muxChapters="\\"
else
	echo "ERROR: muxing chapters"
fi
if [ $hasSubtitles == 1 ]; then
	muxSubtitles="
		--track-name SUBTITLES-$fileName \\ ##[filename inside mkv container of streams]
		--language $language \\ ##[if eng set to english; else error] ONLY ALLOW ENGLISH
		--sub-charset \\
		--subtitle-tracks \\
		$inputFilePath/$fileName.srt \\"
elif [ $hasSubtitles == 0 ]; then
	muxSubtitles="\\"
else
	echo "ERROR: muxing subtitles"
fi
mkvmerge \
## GLOBAL
-o $inputFilePath/$fileName \
--output-charset UTF-8 \
--ui-language eng \ ##[always set to english to force default]
## VIDEO
--default-track $num \ ##[set to default track and default position]
--forced-track \ ##[since its required anyways]
--track-name VIDEO-$fileName \ ##[filename inside mkv container of streams]
--language $language \ ##[if eng set to english; elif no eng set to lang provided; elif und > error]
--default-duration 1:24000/1001fps \ ##[nTrack ID:fps (prevents audio sync issues)]
--video-tracks \
$inputFilePath/$fileName.hvc \
## AUDIO
--default-track $num \ ##[set to default track and default position]
--forced-track \ ##[since its required anyways]
--track-name AUDIO-$fileName \ ##[filename inside mkv container of streams]
--language $language \ ##[if eng set to english; elif no eng set to lang provided; elif und > error]
--audio-tracks \
$inputFilePath/$fileName.opus \
## SUBTITLES
printf $muxSubtitles
## CHAPTERS
printf $muxChapters


echo -e "${colorG}10 of $stepTotal${colorB}............................${colorP}Cleanup${colorD}"
## CLEANUP
## TODO: remove multipass logs
# $workDir/$outFile.ffpass $workDir/$outFile.xpass
if [ "$PASS" == "2" ] ; then
	echo "remove stats.file"
	## x265 stats file [outputFile.stats]
	## ffmpeg redirected output [nul]
	## hvc tmp video [outputFile.hvc]
	## opus tmp audio [oputFile.opus]
	## srt tmp subtitles [outputFiel.srt]
	## xml tmp chapterlist [outputFile.xml]
	rm $inputFilePath/$fileName.hvc
	rm $inputFilePath/$fileName.stats
	rm $inputFilePath/$fileName.opus
	# $fileName.nul
	# $fileName.xml
	# $fileName.srt
else
	echo "do nothing"
fi