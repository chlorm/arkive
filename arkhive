#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended[aac,fdk,mp3,opus]
##      mediainfo
##      awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

# Items to handle

# Video Stream
# Audio Stream
# Subtitles (english only, figure out how to determine which is english if not titled)
# Coverart??????????
# Metadata???????
# Chapterlist

# Source

# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

noColors=0

## [valid file extensions to except]
export exts=(3gp avi flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## [version is incremented when file is updated]
VERSION=1

## [sets current directory as working directory]
function currentDir {
	workDir = $( pwd )
}

## TODO: auto detect if terminal supports color
## [terminal colors]
function colors {
	if [ "${noColors}" -eq 0 ]; then
		colorR="\033[31m" # Red
		colorG="\033[32m" # Green
		colorP="\033[35m" # Purple
		colorB="\033[36m" # Cyan (light blue)
		colorD="\033[0m"  # default
	else
		unset colorR colorG colorP colorB colorD
	fi
}

## TODO: update help informaton and fix colors
# Usage instructions [need to be updated, just an example]
function usage {
	HELP="\${cG}ARKhive version: ${VERSION}
Automates encoding video to ARK's archive format.

Usage: \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}FILE\$cZ [\${cU}OPTIONS\$cZ]\$cZ
       \${cZ}ARKhive [\${cU}OPTIONS\$cZ] \${cU}DIR\$cZ  [\${cU}OPTIONS\$cZ]\$cZ
         \$colorG-o \${cU}DIRECTORY\$cZ        \$cR*\$cZ - set output directory (current is \$cP\${DIR}\$cZ)
         \$colorG-h\$cZ                    - print this message
         \$colorG-v\$cZ                    - print version"
}

## [parse input file and create output filename according to ARK specification]
function out_filename {
	# Television: %title%_S%season#%E%episode#%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bit_depth%.%samplerate%.%ext%
	# Movie: %title%_%year%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bitdepth%.%samlerate%.%ext%
	inputFile
}

function multi_pass {
	# multi-pass encoding
	# start with 1 and increment each time it is run, and exit if >2
	# multi-pass log file [create filename and path]
	multiPassLog=$($workDir/$outputFile.mpass)
}

function cpudetect {
	## [find number of physical cpu cores]
	cpuCores=$(cat /proc/cpuinfo | awk '/^cpu\ cores/{print $4}' | tail -1)
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
}

## Crop Black Bars
## [checks several points in video and takes greatest crop value to prevent from over cropping]
function cropdetect {
    CROP="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		CROP[$A]=$(ffmpeg -i ${workDir}/${inputFile} -ss $skipSecs -t 1 -vf cropdetect \
		-f null - 2>&1 | awk -F "=" '/crop/ { print $NF }' | tail -1)
##		Orginal argument
#        ffmpeg -ss $skipSecs -i "/home/jackal/test.mkv" -vframes 20
#		 -an -sn -vf cropdetect=30:2 -f null 2>&1
#        CROP[$A]=$(grep -m 1 crop= $FFOUT |awk -F "=" '{print $2}')
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${CROP[$B]}" == "${CROP[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            GREATEST="$D"
        fi
    done
    ## [final crop value]
    CROP="${CROP[$GREATEST]}"
#    CROP=$(echo $CROP|awk -F ":" '{print $1-4":"$2-4":"$3+2":"$4+2}')
	## [frame width from final crop value]
    cropWidth=$(echo $CROP | awk -F ":" '{print $1}')
}

## TODO: select english audio channel, exclude commentary
#ffmpeg -i "input" -vn -c:a ac3 -ac 6 -ar 48000 -ab 640k -dialnorm -24 -dsur_mode 0 \
#-original 1 -dmix_mode 2 "output"
function audio_config {
	## [find number of audio channels]
	audioChannels=$(mediainfo ${workDir}${inputFile} | awk '/Channel\(s\)/ { print $3 }' | tail -1)
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	## [set samplerate based on number of channels]
	if ["${audioChannels}" -gt 6 ] ; then
		audioSamRate="48000"
	else
		audioSamRate="44100"
	fi
}

## TODO: remove multipass logs
function cleanup {
	# remove all temp files after completion or cancelation
	# stats file, and anything else
	if [ "${PASS}" == "${passes}" ] ; then
		## rm stats.file
	else
		## do nothing
	fi
}

## TODO: multi-pass while loop
# While pass ==1 or == 2 run the following
function encode {
	ffmpeg -threads $cpuThreads -i $inputFile \
	-pass $pass_count \
	-passlogfile "$workDir/$outputFile.ffmpass" \
	-c:v libx265 -b:v 1024k -minrate 1k -maxrate 32k -r 24000/1001 \
	-vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
	-c:a libopus \
	-ac $audioChannels \
	-ab $audioBitrate \
	-ar $audioSamRate \
	-x265-params "\
	threads=$cpuCores:frame-threads=4:\
	frames=0:\
	wpp:ctu=64:tu-intra-depth=4:tu-inter-depth=4:\
	me=2:subme=7:merange=60:max-merge=5:\
	b-intra:no-tskip:no-constrained-intra:\
	rect:amp:no-early-skip:weightp:weightb:\
	psy-rd=0.15:\
	keyint=250:min-keyint=23:rc-lookahead=60:b-adapt=2:bframes=3:bframe-bias=0:b-pyramid:ref=4:\
	vbv-bufsize=31250:vbv-maxrate=31250:vbv-init=0.9:aq-mode=0:no-cutree:cbqpoffs=3:crqpoffs=3:\
	pass=1:no-slow-firstpass:\
	lft:sao-lcu-opt=1:\
	hash=2"\
	-y "$(workdir)/${output}.mkv"
}

## call functions
colors
usage
## while loop to check for flags
## parse arguments
## options (-v/--version)(-h/--help)(-i/--input)(-o/--output)
while [ "$1" ]; do
	case "$1" in
		-o)			 DIR=$2; shift;;
		-h|--help|-help) eval "$msg \"${HELP}\""; exit 0;;
		-v|--version)
			$msg "ARKhive
			 version: ${VERSION}\n\n";
			lame --version | grep '^LAME';
			exit 0;;
		-*) eval "$msg \"${HELP}\""; emsg "\nUnknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "$msg \"${HELP}\""
				emsg "\nUnknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				emsg "Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done

cropdetect