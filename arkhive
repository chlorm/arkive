#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended:[aac,fdk,mp3,opus]
##      ffprobe
##      mkvtoolnix
##      Obviously: awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

## IDEAS
#> Coverart
#> Remove Logos
# https://www.ffmpeg.org/ffmpeg-filters.html#removelogo
# http://superuser.com/questions/683643/how-to-add-my-logo-for-the-first-30-seconds-in-a-video-with-ffmpeg
#> De-Interlace
# detect for interlaced content and de-interlace
#> File Counter x of # of files processed

## Example application
# https://github.com/macmichael01/ffmpeg-basher/blob/master/ffmpeg.sh

## Bash Portability
# http://wiki.bash-hackers.org/scripting/nonportable

## cut command
# http://www.computerhope.com/unix/ucut.htm

## Shelly - Shell scripts in haskell
# http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts

# http://en.wikipedia.org/wiki/ISO_base_media_file_format

## Source
# https://github.com/z1lt0id/encoder/blob/master/encode-tv
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

## [valid file extensions to except]
allowedExtensions=(avi f4v flv m2ts m4v mpeg mkv mov mp4 ts wmv)
#inputFileExt=${inputFile##*.}

## [version is incremented when file is updated]
VERSION=1

## TODO: only enabled color it terminal supports it
## [add colors once finished]
colorR="\033[1;31m" # Red
colorG="\033[1;32m" # Green
colorP="\033[1;35m" # Purple
colorB="\033[0;36m" # Cyan (light blue)
colorY="\033[0;33m" # Yellow
colorU="\033[0;4m" # Yellow
colorD="\033[0;0m"  # default

## TODO: update help informaton and fix colors
function usage {
	HELP="\n\${colorP}ARKhive version:\${colorG} ${VERSION}
\${colorP}Automates encoding video to ARK's archive format.

Usage: \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}FILE\$colorD [\${colorU}OPTIONS\$colorD]\$colorD
       \${colorD}ARKhive [\${colorU}OPTIONS\$colorD] \${colorU}DIR\$colorD  [\${colorU}OPTIONS\$colorD]\$colorD
         \$colorB-i \${colorU}FILE/DIRECTORY\$colorD   \$colorY*\$colorD - set input file\$colorD
         \$colorB-o \${colorU}DIRECTORY\$colorD          - set output directory (current is \$cP\${DIR}\$colorD)
         \$colorB-t \${colorU}DIRECTORY\$colorD          - set temp directory (current is \$cP\${DIR}\$colorD)
         \$colorB-h\$colorD                    - print this message
         \$colorB-v\$colorD                    - print version\n\n"
}

usage

## TODO: rewrite input to check against allowedExtensions array for reusability instead of explicitly defining
# http://hacktux.com/bash/arrays
## [if no input exit with error]
if [ -z "$1" ];then echo -e "${colorR}ERROR: No arguments provided";exit 0;else
## parse arguments
while [ "$1" ]; do
	case "$1" in
		-i|--input)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No input provided"; exit 0;
			elif [ -f "$2" ]; then
				inputFileExt=${2##*.}
				case "$inputFileExt" in
					avi|f4v|flv|m2ts|m4v|mkv|mp4|mpeg|mpg|mov|ts|wmv)
				   		userInput=$2;shift;;
				   	*)
						echo "ERROR: Selected file's extension is not an allowed type!";
						echo "Allowed file types are: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv";
						exit 0;;
				esac
				shift
			## TODO: improve error message to specify only file or directory
			else echo "ERROR: Input is not a file";exit 0;fi;;
		-o|--output)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output directory provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Output is not a directory";exit 0;
			else userOutput=$2;shift;fi;;
		-t|--temp)
			if [ -z "$2" ];then echo -e "${colorR}ERROR: No output provided";exit 0;
			elif [ ! -d "$2" ];then echo -e "${colorR}ERROR: Temp is not a directory";exit 0;
			else userTemp=$2; shift;fi;;
		-h|--help) eval "printf \"${HELP}\""; exit 0;;
		-v|--version)
			printf "ARKhive version: ${VERSION}\n\n";exit 0;;
		-*) eval "printf \"${HELP}\""; printf "\nERROR: Unknown option $1\n"; exit 1;;
		*)
			if [ -n "${INPATH}" ]; then
				eval "printf \"${HELP}\""
				printf "\nERROR: Unknown option $1\n"
				exit 1
			elif [ ! -r "$1" ]; then
				printf "ERROR: Unable to read $1\n"
				exit 2
			else
				INPATH="$1"
			fi;;
	esac
	shift
done;fi

## TODO: take input file and extact the following: filename, file path, and file extension
## TODO: rename function to parse user input
## TODO: check userInputDir against allowedExtensions array
## TODO: since this function is called by the loop no looping is needed here, only a statement for if the input is dir or file
function parse_filename {
	## [find input file directory]
	cd $(dirname $userInput)
	inputFilePath=$(pwd)
	fileName=${userInput##*/}
	fileName=${fileName%%.*}
	arkMark="-ARK"
	fileName=$fileName$arkMark
	echo "Filename: $fileName"
}

## [cpu detection for encoders]
function cpu_detect {
	## [find number of physical cpu cores]
	cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu cores";exit 0;fi
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)
	if [ -z "$cpuCores" ];then echo -e "${colorR}ERROR: Could not find # of cpu threads";exit 0;fi
	echo "            Cores: $cpuCores Threads: $cpuThreads"
}

## TODO: rewrite to use x265 instead of ffmpeg and rewrite second instance for ffmpeg audio
## video_progress
## audio_progress
## [progress indicator]
function example_progress_counter {
    START=$(date +%s); frameCounter=0; ETA=0; elapsedTime=0
    ## [check to see if ffmpeg is running]
    while [ -e /proc/$PID ]; do
        sleep 2
        ## [parse vstats file]
        VSTATS=$(awk '{gsub(/frame=/, "")}/./{line=$1-1} END{print line}' \
        	$HOME/vstats)
        if [[ $VSTATS -gt $frameCounter ]]; then
            frameCounter=$VSTATS
            ## [progress-bar calc]
            percentageCounter=$(( 100 * frameCounter / totalFrames ))
            elapsedTime=$(( $(date +%s) - START )); echo $elapsedTime > $HOME/elapsed.value
            ## [etc clac]
            ETA=$(date -d @$(awk 'BEGIN{print int(('$elapsedTime' / '$frameCounter') *\
            ('$totalFrames' - '$frameCounter'))}') -u +%H:%M:%S)
        fi
        ## [format for stats output]
        echo -ne "\rFrame:$frameCounter of $totalFrames Time:$(date -d @$elapsedTime -u +%H:%M:%S) ETA:$ETA Percent:$percentageCounter"
   done
}

function audio_progress {
	echo "incomplete"
}

function video_progress {
	echo "incomplete"
}

## [subtitle stream selector]
## TODO: case for subtitle without language set
## TODO: handle videos without subtitles
function sub_titles {
	## use something like cpuThreads, if greater than 0 then continue, else file has no subtitles
	## http://en.wikibooks.org/wiki/FFMPEG_An_Intermediate_Guide/subtitle_options
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i $userInput -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
	#ffmpeg -i $userInput $outputFile.srt
}

## TODO: detect if input has chapters
## TODO: decide on method of transfering chapters from source to output
#		read input file at time of muxing and map chapters
#		output chapters to text file and input into muxing
function chapter_list {
	## use something like cpuThreads, if greater than 0 then continue, else file has no chapters
	## https://www.bunkus.org/videotools/mkvtoolnix/doc/mkvextract.html
	## [finds first english subtitle stream]
	echo " TODO: section"
}

## TODO: find if source contains metadata and depending on feild map export to file
function meta_data {
	## TODO: set creation date
	## http://multimedia.cx/eggs/supplying-ffmpeg-with-metadata/
	## http://jonhall.info/how_to/dump_and_load_metadata_with_ffmpeg
	## add language to streams
	## add title to video
	echo "        metadata doesn't work yet"
}

## [audio stream selection and configuration]
## TODO: audioEngStream only detects mkv english stream, adapt for other formats (m2ts)
## TODO: mkv audio needs to be tested with more possible exceptions (not tested with und audio streams)
## TODO: this section (and subtitles) should contain the most logic to find
## 		 correct streams consistently, should account for all allowed container formats
function config_audio {
	## Contaier Formats: avi flv/f4v m2ts mpeg mkv mov mp4/m4v ts wmv
	## [find audio stream to use]
	if [ -z "$inputFileExt" ]; then echo "ERROR: could not find file extension";exit 0;
	elif [ $inputFileExt == "mkv" ]; then
		## [finds first english audio stream]
		audioEngStream=$(\
			ffmpeg -i $userInput -f null - 2>&1 | \
			grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
			awk -F ":" '{print $2}' | \
			tail -1)
		if [ -z "$audioEngStream" ];then $audioEngStream="2";fi
		## [offset audio stream by one for ffprobe because it counts from zero]
		audioChnStream=$(( $audioEngStream - 1 ))
		## [find number of audio channels]
		audioChannels=$(\
			ffprobe $userInput -show_streams -select_streams a:$audioChnStream 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	else
		## [assume audio stream is 1]
		audioEngStream="1"
		## [find number of audio channels]
		## <select_stream does not seem to work with mp4 container>
		audioChannels=$(\
			ffprobe $userInput -show_streams 2>&1 | \
			awk -F "=" '/channels/ { print $2 }' | \
			tail -1)
		if [ -z "$audioChannels" ];then echo -e "${colorR}ERROR: Could not find # of audio channels";exit 0;fi
	fi
	## [set to 48kbps per channel]
	audioBitrate=$(($audioChannels * 48))
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
	echo "    Stream: $audioEngStream Channels: $audioChannels Bitrate: $audioBitrate"
}

## [black-bar detection and cropping]
function crop_detect {
	cpu_detect >/dev/null
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $userInput -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo "       crop detect $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "        Crop: $crop"
}

## [function calls]
stepTotal="10"
echo -e "${colorG}1 of $stepTotal${colorB}............................${colorP}Filename${colorD}"
parse_filename
echo -e "${colorG}2 of $stepTotal${colorB}................................${colorP}CPUs${colorD}"
cpu_detect
echo -e "${colorG}3 of $stepTotal${colorB}...........................${colorP}Subtitles${colorD}"
echo "Subtitles currently aren't mapped to output"
sub_titles
echo -e "${colorG}4 of $stepTotal${colorB}......................${colorP}TODO: Metadata${colorD}"
meta_data
echo -e "${colorG}5 of $stepTotal${colorB}...................${colorP}Configuring Audio${colorD}"
config_audio
echo -e "${colorG}6 of $stepTotal${colorB}................................${colorP}Crop${colorD}"
echo -e "    ${colorY}WARNING: This step may take a while${colorD}"
crop_detect
echo -e "${colorG}7 of $stepTotal${colorB}......................${colorP}Encoding Audio${colorD}"
echo "encoding audio"
	ffmpeg \
	-i "$userInput" \
	-c:a libopus \
	-map 0:$audioEngStream \
	-ac $audioChannels \
	-b:a $audioBitrate \
	-vbr on \
	-ar 48000 \
	-compression_level 10 \
	-y $inputFilePath/$fileName.opus || \
	{ echo -e "${colorR}ERROR: audio failed to encode"; exit 0; }
echo "audio complete"

## [get duration and fps then calculate total frames]
FPS=$(ffprobe "$userInput" 2>&1 | sed -n "s/.*, \(.*\) tbr.*/\1/p")
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
if [ -z "$totalFrames" ];then echo -e "${colorR}ERROR: Cound not calculate total frames";exit 0;fi

echo -e "${colorG}8 of $stepTotal${colorB}......................${colorP}Encoding Video${colorD}"
## TODO: multi-pass log --stats=/path/file.log
## TODO: redirect ffmpeg output to a tmp file, name same as other files and remove after finished
## [number of encoding passes]
passes="2"
## [initial pass number, DO NOT CHANGE VALUE]
PASS=1
echo "total $totalFrames"
while [ $PASS -le $passes ]; do
	echo "Encoding Pass: $PASS"
    ffmpeg \
    -threads $cpuThreads \
    -i "$userInput" \
    -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
    -r 24000/1001 \
    -pix_fmt yuv420p \
    -f yuv4mpegpipe - 2> nul | \
    x265 \
    --y4m \
    --stats=$inputFilePath/$fileName.stats \
    --threads=$cpuCores \
    --frame-threads=$cpuCores \
    --wpp \
    --ctu=64 \
    --no-cutree \
    --tu-intra-depth=4 \
    --tu-inter-depth=4 \
    --me=2 \
    --cbqpoffs=3 \
    --crqpoffs=3 \
    --psy-rd=0.15 \
    --subme=7 \
    --merange=60 \
    --ref=4 \
    --bframes=3 \
    --b-pyramid \
    --b-adapt=2 \
    --bframe-bias=0 \
    --b-intra \
    --weightb \
    --weightp \
    --bitrate=1024 \
    --vbv-init=0.9 \
    --vbv-bufsize=31250 \
    --vbv-maxrate=31250 \
    --no-slow-firstpass \
    --pass=$PASS \
    --keyint=250 \
    --min-keyint=23 \
    --rc-lookahead=60 \
    --no-constrained-intra \
    --aq-mode=0 \
    --lft \
    --sao-lcu-opt=1 \
    --cbqpoffs=-3 \
    --crqpoffs=-3 \
    --rect \
    --amp \
    --max-merge=5 \
    --no-early-skip \
    --no-tskip \
    --hash=2 \
    -f $totalFrames \
    -o "$inputFilePath/$fileName.hvc" - 

    ## [if pass one complete output message]
    if [ $PASS == 1 ]; then
    	echo "Pass 1 complete"
    elif [ $PASS == 2 ]; then
		echo "Encoding complete"
    else
    	echo -e "ERROR: Something went wrong encoding video"
    fi

    ## [the fps was orginally calculated from source, but the fps may]
    ## [have changed because fps from source is not used, recalculate]
	FPS="23.976023976"
	totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
	## [increment pass count]
    PASS="$(( $PASS + 1 ))"
done

echo -e "${colorG}9 of $stepTotal${colorB}.........................${colorP}Mux Streams${colorD}"
echo -e "  ${colorY}WARNING: You are about to cross the streams${colorD}"
echo "         This section does nothing"
## TODO: decide between ffmpeg and mkvtoolniv [mkvmerge] for muxing finished files
## http://cfc.kizzx2.com/index.php/muxing-audio-and-video-with-ffmpeg/
## metadata if any to be added here
#	ffmpeg \
#	-i ## video \
#	-i ## audio \
#	-i ## subtitles (if any) \
#	-i ## chapter list (if any) \
#	-vcodec copy
#	-acodec copy


echo -e "${colorG}10 of $stepTotal${colorB}............................${colorP}Cleanup${colorD}"
## CLEANUP
## TODO: remove multipass logs
# $workDir/$outFile.ffpass $workDir/$outFile.xpass
if [ "$PASS" == "2" ] ; then
	echo "remove stats.file"
	## x265 stats file [outputFile.stats]
	## ffmpeg redirected output [nul]
	## hvc tmp video [outputFile.hvc]
	## opus tmp audio [oputFile.opus]
	## srt tmp subtitles [outputFiel.srt]
	## xml tmp chapterlist [outputFile.xml]
	# $fileName.hvc
	# $fileName.stats
	# $fileName.opus
	# $fileName.nul
	# $fileName.xml
	# $fileName.srt
else
	echo "do nothing"
fi