#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      ffmpeg[encode,libass,libx265,threads] recommended[aac,fdk,mp3,opus]
##      mediainfo
##      awk, bash, cat, grep, pwd, tail
##    Assumed Directory & File Structure:
##      ~/.config/ARKhive/ ------------ config directory??????????????
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      # -- commented variables

## Items to handle
# Video Stream ^
# Audio Stream ^
# Subtitles (english only, figure out how to determine which is english if not titled) ^
# Coverart?????????? TODO
# Metadata??????? TODO
# Chapterlist TODO

## Source
# a-Bluray
# b-Bluray-Rip
# c-HDTV
# d-DVD
# e-SDTV
# f-Cam
# g-Telesync
# h-Screener
# i-Telecine

inputFile=$@

#noColors=0

## [valid file extensions to except]
#export exts=(3gp avi flv m2ts m4v mpeg mkv mov mp4 ts wmv)

## [version is incremented when file is updated]
#VERSION=1

function current_dir {
	## [sets current directory as working directory]
	workDir=$( pwd )
	echo "Working Directory: $workDir"
}

function out_filename {
## [parse input file and create output filename according to ARK specification]
	# Television: %title%_S%season#%E%episode#%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bit_depth%.%samplerate%.%ext%
	# Movie: %title%_%year%_%country%_%vcodec%.%resolution%_%acodec%.%channels%.%bitdepth%.%samlerate%.%ext%
	#outputFile=$(cat $inputFile | )
	outputFile=$inputFile
}

function cpu_detect {
	## [find number of physical cpu cores]
	cpuCores=$(\
		cat /proc/cpuinfo | \
		awk '/^cpu\ cores/{print $4}' | \
		tail -1)
	## [find number of cpu threads]
	cpuThreads=$(grep -c ^processor /proc/cpuinfo)

	echo "            Found CPU details"
	echo "           Cores: $cpuCores Threads: $cpuThreads"
}

function sub_titles {
	## [finds first english subtitle stream]
	subtitleEng=$(\
		ffmpeg -i /home/jackal/test3.mkv -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
}

## TODO: everything
function meta_data {
	## add language to streams
	## add title to video
	echo "        metadata doesn't work yet"
}

function audio_find_stream {
	## [finds first english audio stream]
	audioEngStream=$(ffmpeg -i $workDir/$inputFile -f null - 2>&1 | \
		grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Audio)' | \
		awk -F ":" '{print $2}' | \
		tail -1)
}

function audio_find_channels {
	audio_find_stream
	## [offset audio stream by one for ffprobe because it counts from zero]
	audioChnStream=$(( $audioEngStream - 1 ))
	## [find number of audio channels]
	audioChannels=$(ffprobe $workDir/$inputFile -show_streams -select_streams a:$audioChnStream 2>&1 | \
		awk -F "=" '/channels/ { print $2 }' | \
		tail -1)
}

function audio_set_bitrate {
	audio_find_channels
	## [set to 48kbps per channel]
	audioBitrate="$(( $audioChannels * 48 ))"
	audioBitrateUnit="k"
	audioBitrate="$audioBitrate$audioBitrateUnit"
}

function audio_set_samplerate {
	audio_find_channels
	## [set samplerate based on number of channels]
	if [[ "$audioChannels" -gt 4 ]] ; then
		audioSamRate="48000"
	else
		audioSamRate="44100"
	fi
}

function audio_encode {
	audio_find_stream
	audio_find_channels
	audio_set_bitrate
	audio_set_samplerate
	cpu_detect

	ffmpeg -threads $cpuCores -i $inputFile -c:a libopus -map 0:$audioEngStream \
	-ac $audioChannels -b:a $audioBitrate -vbr on -ar $audioSamRate \
	-compression_level 10 -y $workDir/$outputFile.opus
}

function crop_detect {
	cpu_detect >/dev/null 2>&1
	## [several checks to accurately crop black-bars]
    crop="1"
    totalLoops="10"
    ## [gather crop values]
    A=0
    while [ "$A" -lt "$totalLoops" ] ; do
        A="$(( $A + 1 ))"
        skipSecs="$(( 120 * $A ))"
		crop[$A]=$(\
			ffmpeg -threads $cpuCores -i $workDir/$inputFile -ss $skipSecs \
			-t 1 -vf cropdetect -f null - 2>&1 | \
			awk -F "=" '/crop/ { print $NF }' | \
			tail -1)
		echo "     crop detection $A of 10 complete"
    done
    B=0
    while [ "$B" -lt "$totalLoops" ] ; do
        B="$(( $B + 1 ))"
    	C=0
    	while [ "$C" -lt "$totalLoops" ] ; do
    	    C="$(( $C + 1 ))"
    		if [ "${crop[$B]}" == "${crop[$C]}" ] ; then
    		    countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
    		fi
    	done
    done
    ## [find greatest crop]
    highestCount=0
    D=0
    while [ "$D" -lt "$totalLoops" ] ; do
        D="$(( $D + 1 ))"
        if [ "${countCrop[$D]}" -gt "$highestCount" ] ; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
        fi
    done
    ## [final crop value]
    crop="${crop[$greatest]}"
	## [frame width from final crop value]
    cropWidth=$(echo $crop | awk -F ":" '{print $1}')
    echo "Crop detection complete"
    echo "Crop: $crop"
}

## TODO: multi-pass while loop ???not sure if it works???
## TODO: figure out multi-pass ffmpeg vs. x265 [does ffpeg -pass even work with libx265]
## TODO: multi-pass log
function encode_video {

	passes="2"
	PASS=0
	while [ "$PASS" -le "$passes" ] ; do

		ffmpeg \
		-threads $cpuThreads \
		-i $inputFile \
		-pass $PASS \
		-passlogfile "\$workDir/\$outputFile.ffpass" \
		-c:v libx265 \
		-b:v 1024k \
		-minrate 1k \
		-maxrate 32k \
		-r 24000/1001 \
		-vf "crop=\$crop,scale=\$cropWidth:trunc(ow/a/2)*2" \
		-c:a libopus \
		-ac $audioChannels \
		-ab $audioBitrate \
		-ar $audioSamRate \
		-x265-params "\
		threads=$cpuCores:frame-threads=$cpuCores:\
		frames=0:\
		wpp:ctu=64:tu-intra-depth=4:tu-inter-depth=4:\
		me=2:subme=7:merange=60:max-merge=5:\
		b-intra:no-tskip:no-constrained-intra:\
		rect:amp:no-early-skip:weightp:weightb:\
		psy-rd=0.15:\
		keyint=250:min-keyint=23:rc-lookahead=60:b-adapt=2:bframes=3:bframe-bias=0:b-pyramid:ref=4:\
		vbv-bufsize=31250:vbv-maxrate=31250:vbv-init=0.9:aq-mode=0:no-cutree:cbqpoffs=3:crqpoffs=3:\
		pass=\$PASS:no-slow-firstpass:\
		lft:sao-lcu-opt=1:\
		hash=2"\
		-y "\$workDir/\$outputFile.mkv"

		PASS="$(( $PASS + 1 ))"
	done
	echo "Encoding complete"
}

## TODO: remove multipass logs
function cleanup {
	# $workDir/$outFile.ffpass $workDir/$outFile.xpass
	if [ "${PASS}" == "${passes}" ] ; then
		echo "rm stats.file"
	else
		echo "do nothing"
	fi
}

## function calls
echo "1 of numVal............................Filename"
out_filename
echo "2 of numVal................................CPUs"
cpu_detect
echo "4 of numVal................................Crop"
crop_detect
echo "5 of numVal...........................Subtitles"
sub_titles
echo "6 of numVal......................TODO: Metadata"
meta_data
echo "3 of numVal...................Configuring Audio"
config_audio
echo "7 of numVal......................Encoding Audio"
encode_audio
echo "8 of numVal......................Encoding Video"
encode_video
echo "9 of numVal.............................Cleanup"
cleanup
## TODO: finish this section