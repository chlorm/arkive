#!/bin/sh
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      fdkaac
##      ffmpeg[encode,ffprobe,fdkaac,threads] >=2.3.x
##      mkvtoolnix[mkvextract,mkvmerge]
##      opus
##      VobSub2SRT
##      x264
##      x265 >=1.3.x
##      Obviously: awk, bash, cat, grep, pwd, tail, rm
##    Assumed Directory & File Structure:
##      /usr/bin?
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      <> - issue description
##      # -- commented variables

VERSION=3

## [audio]
#audioChannelBitrate
#audioSampleRate
#audioLanguage

## [video]
#videoBitrate
#videoFrameRate
#videoResolution

## [subtitles]
#subtitleLanguage

## [Exit Codes]
# 0 = Success
# 1 = Input Error
# 2 = Could Not Find Value Error

# TODO: 

# ERROR: something went wrong and program will exit
# WARNING: something went wrong, but program will continue

## [colors]
clR="\033[1;31m"  # Red
clG="\033[1;32m"  # Green
clW="\033[1;37m"  # White
clP="\033[1;35m"  # Purple
clGa="\033[0;30m" # Gray
clC="\033[0;36m"  # Cyan (light blue)
clY="\033[0;33m"  # Yellow
clU="\033[0;4m"   # Underline
clD="\033[0;0m"   # default

usage () {
    HELP="\n\${clC}ARKhive version:\${clG} ${VERSION}
\${clC}Automated video encoding according to Chlorm's ARK specifications.

Usage: \${clD}arkhive [\${clU}\${clP}OPTIONS\$clD] \${clU}\${clP}FILE\$clD [\${clU}\${clP}OPTIONS\$clD]\$clD
    \$clG-i|--input  \${clU}\${clP}FILE\$clD          \$clY*\$clD - set input file\$clD
    \$clG-o|--output \${clU}\${clP}DIRECTORY\$clD       - set output directory\$clD
    \$clG-t|--temp   \${clU}\${clP}DIRECTORY\$clD       - set temp directory\$clD
    \$clG-h|--help\$clD                   - print this message
    \$clG-v|--version\$clD                - print version\n\n"
}

usage

if [ -z "$1" ]; then
    echo -e "${clR}ERROR: No arguments provided"
    exit 1
else
  # Parse Arguments
  while [ "$1" ]; do
    case "$1" in
      -i|--input)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No input provided"
          exit 1
        elif [ -f "$2" ]; then
          inputFileExt=${2##*.}
          case "$inputFileExt" in
            avi|f4v|flv|m2ts|m4v|mkv|mp4|mpeg|mpg|mov|ts|wmv)
              userInput="$2"
              shift
            ;;
            *)
              printf "${clR}ERROR: Selected file is not a supported format!\n";
              printf "${clY}Supported: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv\n";
              exit 1
            ;;
          esac
        else
          printf "${clR}ERROR: Input file does not exist\n"
          exit 1
        fi
      ;;
      -o|--output)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No output directory provided"
          exit 1
        elif [ ! -d "$2" ]; then
          echo -e "${clR}ERROR: Output is not a directory"
          exit 1
        else
          userOutput=$2
          shift
        fi
      ;;
      -t|--temp)
        if [ -z "$2" ]; then
          echo -e "${clR}ERROR: No temp directory provided"
          exit 1
        elif [ ! -d "$2" ]; then
          echo -e "${clR}ERROR: Temp is not a directory"
          exit 1
        else
          userTemp="$2"
          shift
        fi
      ;;
      -ve|--videoencoder)
        videoEncoder="$2"
        shift
      ;;
      -h|--help) eval "printf \"${HELP}\"";exit 1;;
      -v|--version)
        printf "ARKhive version: ${VERSION}\n\n";exit 1;;
      -*) eval "printf \"${HELP}\"";printf "\n${clR}ERROR: Unknown option $1\n";exit 1;;
      *)
        if [ -n "${INPATH}" ]; then
          eval "printf \"${HELP}\""
          printf "\n${clR}ERROR: Unknown option $1\n";exit 1
        elif [ ! -r "$1" ]; then
          printf "${clR}ERROR: Unable to read $1\n";exit 1
        else
          INPATH="$1"
        fi
      ;;
    esac
    shift
  done
fi
# Make sure user has provided input
if [ -z "$userInput" ]; then
  eval "printf \"${HELP}\""
  echo -e "${clR}ERROR: no input provided"
  exit 
fi

input_directory () {
  # Input file directory
  cd $(dirname $userInput)
  pwd
}

output_directory () {
  # Output directory
  if [ -z "$userOutput" ]; then
    input_directory
  else
    cd $userOutput
    pwd
  fi
}

temp_directory () {
  # Temp directory
  if [ -z "$userTemp" ]; then
    input_directory
  else
    cd $userTemp
    pwd
  fi
}

filename () {
  # Input filename w/ ext
  fileName=$(basename "$userInput")

  # Input filename w/o ext
  fileName=$(echo "$fileName" | sed -r 's/\.[[:alnum:]]+$//')

  # Add tag
  arkMark="-ARK"
  echo "$fileName$arkMark"
}

cpu_cores () {
  ## [cpu cores]
  local cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)
  if [ -z "$cpuCores" ]; then
    echo -e "${clR}ERROR: Could not find # of cpu cores"
    exit 2; fi
  echo "$cpuCores"
}

cpu_threads () {
  ## [cpu threads]
  local cpuThreads=$(grep -c ^processor /proc/cpuinfo)
  if [ -z "$cpuCores" ]; then
    echo -e "${clR}ERROR: Could not find # of cpu threads"
    exit 2; fi
  echo "$cupThreads"
}

## TODO: case for subtitle without language set
## TODO: use for loop to find all english subs in file
##      after finding subs look for plain text subs
## TODO: parse vobsub2srt output and remove ERROR:... lines
## TODO: add support for PGS subtitles
##      if pgs use bdsup2sub to covert to sub/idx and then vobsub2srt
subtitles () {
  ## [find if video has subtitles]
  hasSubtitles=$(\
    ffprobe $userInput 2>&1 | \
    awk '/Subtitle/ { print $2 }')

  ## [no subtitles were found]
  if [ -z "$hasSubtitles" ]; then
    return 0
  ## [subtitles were found]
  else
    ## [finds first english subtitle stream]
    subtitleStream=$(\
      ffmpeg -i $userInput -f null - 2>&1 | \
      grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
      awk -F ":" '{print $2}' | tail -1)

    if [ -z "subtitleStream" ]; then echo "no english subtitles found"; fi

    mkvextract -q tracks $userInput $subtitleStream:temp_directory/filename 2>/dev/null
    echo -e "       ${clC}Found English Subs, Stream: ${clP}$subtitleStream"

    ## [check for and convert VobSub to SRT]
    if [ -f "$tempFilePath/$fileName.idx" ]; then
      echo "         Converting VobSub to SRT"
      vobsub2srt $(temp_directory)/$(filename) &>/dev/null || \
      { echo "WARNING: failed to convert vobsub to srt"; }; fi
  fi
}

chapters () {
  # Find chapters if any exist
  hasChapters=$(ffprobe -i $userInput 2>&1 | awk '/Chapter/ { print $2 }')

  # Videos has no chapters
  if [ -z "$hasChapters" ]; then
    echo "Video has no chapters"
  # Video has chapters
  else
    mkvextract \
      chapters \
      --simple $userInput \
      --redirect-output $(temp_directory)/$(filename).xml || \
      { echo "WARNING: Failed to extract chapters from source";\
        return 1; }
  fi
}

## UNSUPPORTED: avi with multiple audio streams
## CONTAINERS WITH NO LANGUAGE CODES: avi,m2ts,ts
audio_input_stream () {
  # Add all streams with audio into an array
  # <There is a lot or trickery required to get the stream
  #  number that is container specific, so 'or' statements were
  #  added to work around this>
  audioStreamArray=($(\
    ffprobe -i test4.mp4 2>&1 | \
    grep "Audio:" | \
    awk '/Stream\ #0:/ { print $2 }' | \
    grep -o -P '(?<=\#0\:)[0-9](?=\([a-z]+\)|\[[0-9]+x[0-9]+\]|\:)'))

  # Find total number of audio streams in the container
  audioStreamCount=$(${#audioStreamArray[@]})

  if [ -z "$audioStreamCount" ]; then echo "WARNING: No audio streams found"
  elif [ "$audioStreamCount" = "1" ]; then
    # Set stream number to the only one found
    audioPrefferedStream=$($audioStreamArray[1])

  # Containers with: mkv,mp4
  # MP4 has two audio lines, only one with a stream section
  elif [ "$audioStreamCount" -gt "1" ]; then
    # get pounded in the ass

    # Not sure where to start with this section

  # Find language of audio stream
  ffprobe -i test4.mp4 2>&1 | \
    # Gets line of streams
    grep "Stream #0:1" | \
    # Pulls first part of line containing language
    awk '/Stream\ #0:1/ { print $2 }' | \
    # Pulls the three digit language code
    # ISO 639-2/B
    grep -m 1 -o -P '(?<=\#0\:1\().*(?=\):)'
  # 3 
  #  if only one audio stream take it
  #  if not, see if any audio streams contain english
  #    if so, see if there are multiples
  #      select best option 
  #  if not, see if there is anything other than "und"
  #  if not, see if there are multiple und
  #    if so, pick best option
  else
    echo "ERROR: Video has no audio"
    exit 2
  fi

  # 4 Fuck Bitches
}
    
audio_input_sample_rate () {
  ffprobe -i $userInput 2>&1 | \
    grep -m 1 "Stream #0:$primaryAudioStream" | \
    awk -F ", " '/Hz/ { print $2 }'
}

## TODO: add support to automatically remap surround-sound channels in a consistent manner
## get rid of 5.1(side)  it is annoying on a 7.1 setup even if it is technically extended stereo
audio_channel_layout () {
  # Finds channel layout
  findChannelLayout=$(ffprobe -i $userInput 2>&1 | \
    grep -m 1 "Stream #0:$primaryAudioStream" | \
    awk -F ", " '/44100\ Hz/ { print $3 }')

  # Determine channel layout for later use
  # https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/channel_layout.c
  # https://github.com/FFmpeg/FFmpeg/blob/master/doc/utils.texi

  # 0 = FL - Front Left
  # 1 = FR - Front Right
  # 2 = FC - Front Center
  # 3 = LFE - Low Frequency
  # 4 = BL - Back Left
  # 5 = BR - Back Fight
  # 6 = FLC - Front Left-of-Center
  # 7 = FRC - Front Right-of-Center
  # 8 = BC - Back Center
  # 9 = SL - Side Left
  # 10 = SR - Side Right
  # 11 = TC - Top Center
  # 12 = TFL - Top Front Left
  # 13 = TFC - Top Front Center
  # 14 = TFR - Top Front Right
  # 15 = TBL - Top Back Left
  # 16 = TBC - Top Back Center
  # 17 = TBR - Top Back Right
  # 29 = DL - Downmix Left
  # 30 = DR - Downmix Right
  # 31 = WL - Wide Left
  # 32 = WR - Wide Right
  # 33 = SDL - Surround Direct Right
  # 34 = SDR - Surround Direct Left
  # 35 = LFE2 - Low Frequency 2

  if [ -z $findChannelLayout ]; then
    echo "ERROR: could not detect audio channel layout"
    exit 1
    # AV_CH_LAYOUT_MONO
  elif [ $findChannelLayout = "mono" ]; then
    audioChannels="1"
    # AV_CH_LAYOUT_MONO
    # FC
  elif [ $findChannelLayout = "stereo" ]; then
    audioChannels="2"
    # AV_CH_LAYOUT_STEREO
    # FL+FR
  elif [ $findChannelLayout = "2.1" ]; then
    audioChannels="3"
    # AV_CH_LAYOUT_2POINT1
    # FL+FR+LFE
  elif [ $findChannelLayout = "3.0" ]; then
    audioChannels="3"
    # AV_CH_LAYOUT_SURROUND
    # FL+FR+FC
  elif [ $findChannelLayout = "3.0(back)" ]; then
    audioChannels="3"
    # AV_CH_LAYOUT_2_1
    # FL+FR+BC
  elif [ $findChannelLayout = "4.0" ]; then
    audioChannels="4"
    # AV_CH_LAYOUT_4POINT0
    # FL+FR+FC+BC
  elif [ $findChannelLayout = "quad" ]; then
    audioChannels="4"
    # AV_CH_LAYOUT_QUAD
    # FL+FR+BL+BR
  elif [ $findChannelLayout = "quad(side)" ]; then
    audioChannels="2"
    # AV_CH_LAYOUT_2_2
    # FL+FR+SL+SR
  elif [ $findChannelLayout = "3.1" ]; then
    audioChannels="4"
    # AV_CH_LAYOUT_3POINT1
    # FL+FR+FC+LFE
  elif [ $findChannelLayout = "4.1" ]; then
    audioChannels="5"
    # AV_CH_LAYOUT_4POINT1
    # FL+FR+FC+LFE+BC
  elif [ $findChannelLayout = "5.0" ]; then
    audioChannels="5"
    # AV_CH_LAYOUT_5POINT0_BACK
    # FL+FR+FC+BL+BR
  elif [ $findChannelLayout = "5.0(side)" ]; then
    audioChannels="5"
    # AV_CH_LAYOUT_5POINT0
    # FL+FR+FC+SL+SR
  elif [ $findChannelLayout = "5.1" ]; then
    audioChannels="6"
    # AV_CH_LAYOUT_5POINT1_BACK
    # FL+FR+FC+LFE+BL+BR
  elif [ $findChannelLayout = "5.1(side)" ]; then
    audioChannels="6"
    # AV_CH_LAYOUT_5POINT1
    # FL+FR+FC+LFE+SL+SR
  elif [ $findChannelLayout = "6.0" ]; then
    audioChannels="6"
    # AV_CH_LAYOUT_6POINT0
    # FL+FR+FC+BC+SL+SR
  elif [ $findChannelLayout = "6.0(front)" ]; then
    audioChannels="6"
    # AV_CH_LAYOUT_6POINT0_FRONT
    # FL+FR+FLC+FRC+SL+SR
  elif [ $findChannelLayout = "hexagonal" ]; then
    audioChannels="6"
    # AV_CH_LAYOUT_HEXAGONAL
    # FL+FR+FC+BL+BR+BC
  elif [ $findChannelLayout = "6.1" ]; then
    audioChannels="7"
    # AV_CH_LAYOUT_6POINT1
    # FL+FR+FC+LFE+BC+SL+SR
  elif [ $findChannelLayout = "6.1(back)" ]; then
    audioChannels="7"
    ## TODO: fix upstream
    # actually 6.1, not 6.1(back), upstream typo
    # AV_CH_LAYOUT_6POINT1_BACK
    # FL+FR+FC+LFE+BL+BR+BC
  elif [ $findChannelLayout = "6.1(front)" ]; then
    audioChannels="7"
    # AV_CH_LAYOUT_6POINT1_FRONT
    # FL+FR+LFE+FLC+FRC+SL+SR
  elif [ $findChannelLayout = "7.0" ]; then
    audioChannels="7"
    # AV_CH_LAYOUT_7POINT0
    # FL+FR+FC+BL+BR+SL+SR
  elif [ $findChannelLayout = "7.0(front)" ]; then
    audioChannels="7"
    # AV_CH_LAYOUT_7POINT0_FRONT
    # FL+FR+FC+FLC+FRC+SL+SR
  elif [ $findChannelLayout = "7.1" ]; then
    audioChannels="8"
    # AV_CH_LAYOUT_7POINT1
    # FL+FR+FC+LFE+BL+BR+SL+SR
  elif [ $findChannelLayout = "7.1(wide)" ]; then
    audioChannels="8"
    # AV_CH_LAYOUT_7POINT1_WIDE_BACK
    # FL+FR+FC+LFE+BL+BR+FLC+FRC
  elif [ $findChannelLayout = "7.1(wide-side)" ]; then
    audioChannels="8"
    # AV_CH_LAYOUT_7POINT1_WIDE
    # FL+FR+FC+LFE+FLC+FRC+SL+SR
  elif [ $findChannelLayout = "octagonal" ]; then
    audioChannels="8"
    # AV_CH_LAYOUT_OCTAGONAL
    # FL+FR+FC+BL+BR+BC+SL+SR
  elif [ $findChannelLayout = "downmix" ]; then
    audioChannels="2"
    # AV_CH_LAYOUT_STEREO_DOWNMIX
    # DL+DR
  else
    echo "ERROR: Unsupported channel layout"
    exit 1
  fi
}

audio () {
  audio_channel_layout
  # Bitrate per channel (set to 48kbps)
  audioBitrate=$(($audioChannels * 48))
  audioBitrateUnit="k"
  audioBitrate="$audioBitrate$audioBitrateUnit"
}

crop_detect () {
  ## [several checks to accurately crop black-bars]
  crop="1"
  totalLoops="10"
  ## [gather crop values]
  A=0
  while [ "$A" -lt "$totalLoops" ]; do
    A="$(( $A + 1 ))"
    skipSecs="$(( 120 * $A ))"
    crop[$A]=$(\
      ffmpeg -threads $(cpu_cores) -i $userInput -ss $skipSecs \
      -t 1 -vf cropdetect -f null - 2>&1 | \
      awk -F "=" '/crop/ { print $NF }' | tail -1)
    echo -ne "\r       ${clC}crop detect ${clP}$A ${clC}of ${clP}10 ${clC}complete"
  done
  B=0
  while [ "$B" -lt "$totalLoops" ]; do
    B="$(( $B + 1 ))"
    C=0
    while [ "$C" -lt "$totalLoops" ]; do
      C="$(( $C + 1 ))"
      if [ "${crop[$B]}" == "${crop[$C]}" ]; then
        countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
      fi
    done
  done
  ## [find greatest crop]
  highestCount=0
  D=0
  while [ "$D" -lt "$totalLoops" ]; do
    D="$(( $D + 1 ))"
    if [ "${countCrop[$D]}" -gt "$highestCount" ]; then
      highestCount="${countCrop[$D]}"
      greatest="$D"
    fi
  done
  ## [final crop value]
  crop="${crop[$greatest]}"
  ## [frame width from final crop value]
  cropWidth=$(echo $crop | awk -F ":" '{print $1}')
  echo -e "\n             Crop: ${clP}$crop"
}

# Deinterlace video
#
#
# TODO
#

# Call Functions
chapters
subtitles
audio

# Encode Audio
ffmpeg \
-i "$userInput" \
-c:a libfdk_aac \
-map 0:$audioEngStream \
-ac $audioChannels \
-b:a $audioBitrate \
-ar 48000 \
-y $(temp_directory)/$(filename).aac || \
{ echo -e "${clR}ERROR: audio failed to encode";exit 0; }

# Frames Per Second
FPS="23.976023976"
# Get Duration
totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
HRS=$(echo $totalLength | cut -d":" -f1)
MIN=$(echo $totalLength | cut -d":" -f2)
SEC=$(echo $totalLength | cut -d":" -f3)
# Get total number of frames
totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
echo "Estimated total frames: $totalFrames"

# Number of encoding passes
passes="2"

# Initial pass number, DO NOT CHANGE VALUE
PASS="1"

while [ $PASS -le $passes ]; do

  echo -e "${clC}Encoding Pass: ${clP}$PASS ${clC}of ${clP}$passes${clD}"

  # x264
  if [ $videoEncoder == "x264" ]; then
    ffmpeg \
      -threads $cpuThreads \
      -i "$userInput" \
      -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
      -r 24000/1001 \
      -pix_fmt yuv420p \
      -f yuv4mpegpipe - |
    x264
      --demuxer y4m
      --cabac --ref=4
      --deblock=1:-1:-1
      --analyse=0x3:0x133
      --me=umh
      --subme=9
      --psy
      --psy-rd=0:0
      --mixed-ref
      --merange=24
      --trellis=2
      --8x8dct
      --cqm=jvt
      --deadzone-inter=21
      --deadzone-intra=11
      --no-fast-pskip
      --chroma-qp-offset=-3
      --threads=8
      --lookahead-threads=1
      --nr=0
      --no-interlaced
      --constrained-intra
      --bframes=3
      --b-pyramid=2
      --b-adapt=2
      --b-bias=0
      --direct=temporal
      --weightb
      --weightp=2
      --keyint=250
      --min-keyint=2
      --scenecut=40
      --rc-lookahead=60
      --pass=1
      --mbtree
      --cplxblur=20.0
      --qblur=0.5
      --ratetol=1.
      --qcomp=0.60
      --qpmin=0
      --qpmax=69
      --qpstep=
      --fps=24000/1001
      --bitrate=1762
      --nal-hrd=vbr
      --vbv-maxrate=31250
      --vbv-bufsize=31250
      --ipratio=1.40
      --aq=1.0
      --output $(temp_directory)/$(filename).avc -

  # x265 (default)
  else
    ## [ffmpeg piped to x265]
    ## TODO: determine if crop height or width are odd numbers and if so
    ##        enable ffmpeg scaling otherwise disable
    ## TODO: make ffmpeg output to $fileName.ffmpeg
    ffmpeg \
      -threads $(cpu_threads) \
      -i "$userInput" \
      -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
      -r 24000/1001 \
      -pix_fmt yuv420p \
      -f yuv4mpegpipe - 2> nul | \
    x265 \
      --y4m \
      --stats=$tempFilePath/$fileName.stats \
      --threads=$(cpu_cores) \
      --frame-threads=$cpuCores \
      --wpp \
      --ctu=64 \
      --no-cutree \
      --tu-intra-depth=4 \
      --tu-inter-depth=4 \
      --me=2 \
      --cbqpoffs=3 \
      --crqpoffs=3 \
      --psy-rd=0.15 \
      --subme=7 \
      --merange=60 \
      --ref=4 \
      --bframes=3 \
      --b-pyramid \
      --b-adapt=2 \
      --bframe-bias=0 \
      --b-intra \
      --weightb \
      --weightp \
      --bitrate=1024 \
      --vbv-init=0.9 \
      --vbv-bufsize=31250 \
      --vbv-maxrate=31250 \
      --no-slow-firstpass \
      --pass=$PASS \
      --keyint=250 \
      --min-keyint=23 \
      --rc-lookahead=60 \
      --no-constrained-intra \
      --aq-mode=0 \
      --lft \
      --sao-lcu-opt=1 \
      --cbqpoffs=-3 \
      --crqpoffs=-3 \
      --rect \
      --amp \
      --max-merge=5 \
      --no-early-skip \
      --no-tskip \
      --hash=2 \
      -f 0 \
      -o "$(temp_directory)/$(filename).hvc" - || \
      { echo "ERROR: video encoding failed";exit 0; }
  fi

  # Finished encoding
  if [ $PASS == $passes ]; then
    echo
    echo "Encoding complete"
  # Not finised encoding
  else 
    echo; fi

  # Increment pass count
  PASS="$(( $PASS + 1 ))"
done

# mkvmerge
# -o "$rar_variable-s.mkv"
# "--default-track" "0:yes"
# "--forced-track" "0:no"
# "--language" "1:eng"
# "--track-name"
# "1:English"
# "--default-track"
# "1:yes"
# "--forced-track"
# "1:no"
# "--language" "2:eng"
# "--default-track" "2:yes" "--forced-track"
# "2:no" "-a" "1" "-d" "0" "-s" "2" "-T" "--no-global-tags"
# "--no-chapters" "(" "$rlsname_variable.mkv" ")"
# "--track-order" "0:0,0:1,0:2" "--split" "parts:00:01:30-00:02:30"

    ## [check for chaper file]
    if [ -f "$(temp_directory)/$(filename).xml" ]; then
        muxChapters="--chapters $(temp_directory)/$(filename).xml"
    else
        muxChapters=""; fi

    ## [check for subtitle file]
    if [ -f "$(temp_directory)/$(filename).srt" ]; then
        muxSubtitles="$(temp_directory)/$(filename).srt"
    else
        muxSubtitles=""; fi

    ## TODO: find audio language and set videolanguage to audiolanguage
    mkvmerge \
        -o $(output_directory)/$(filename).mkv \
        --title $(filename) \
        -A $(temp_directory)/$(filename).hvc \
        $muxChapters \
        $muxSubtitles \
        $(temp_directory)/$(filename).aac

## ffmpeg redirected output [nul]

## [delete video]
if [ -f "$(temp_directory)/$(filename).hvc" ]; then
  rm $(temp_directory)/$(filename).hvc
  echo "Removed $(filename).hvc"; fi

## [delete x265 multi-pass log]
if [ -f "$(temp_directory)/$(filename).stats" ]; then
  rm $(temp_directory)/$(filename).stats
  echo "Removed $(filename).stats"; fi

## [delete audio]
if [ -f "$(temp_directory)/$(filename).opus" ]; then
  rm $(temp_directory)/$(filename).aac
  echo "Removed $(filename).aac"; fi

## [delete subtitles]
if [ -f "$(temp_directory)/$(filename).sub" ]; then
  rm $(temp_directory)/$(filename).sub
  echo "Removed $(filename).sub"; fi
if [ -f "$(temp_directory)/$(filename).idx" ]; then
  rm $(temp_directory)/$(filename).idx
  echo "Removed $(filename).idx"; fi
if [ -f "$(temp_directory)/$(filename).srt" ]; then
  rm $(temp_directory)/$(filename).srt
  echo "Removed $(filename).srt"; fi

## [delete chapter list]
if [ -f "$(temp_directory)/$(filename).xml" ]; then
  rm $(temp_directory)/$(filename).xml
  echo "Removed $(filename).xml"; fi