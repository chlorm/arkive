#!/usr/bin/env bash
##       ________   ___       ___
##      /  _____/  /  /      /  /
##     /  /       /  /      /  /
##    /  /       /  /____  /  / _______  _______  ____  ____
##   /  /       /  ___  / /  / /  __  / /  ____/ /    \/    \
##  /  /_____  /  /  / / /  / /  /_/ / /  /     /  /\    /\  \
## /________/ /__/  /_/ /__/ /______/ /__/     /__/  \__/  \__\ TM
##
## Title: ARKhive
## Author: Cody Opel
## E-mail: codyopel(at)gmail.com
## Copyright (c) 2014 All Rights Reserved, http://www.chlorm.net
## License: The MIT License - http://opensource.org/licenses/MIT
## Comments:
##    Dependencies:
##      fdkaac
##      ffmpeg[encode,ffprobe,fdkaac,threads] >=2.3.x
##      mkvtoolnix[mkvextract,mkvmerge]
##      opus
##      VobSub2SRT
##      x265 >=1.3.x
##      Obviously: awk, bash, cat, dirname, grep, pwd, tail, rm
##    Legend:
##      () - option
##      [] - description
##      ## - comments [not to be uncommented]
##      <> - issue description
##      # -- commented variables

VERSION="3"

# ERROR: something went wrong and program will exit
# WARNING: something went wrong, but program will continue

# EXIT CODES
# 1 - Input error

# RETURN CODES
# 2 - Cpu detection error


################################################################################
################################### SETTINGS ###################################
################################################################################

  containerFormat="mkv" #(mkv,mp4)

  languageDefault="eng" # ISO xxxx

  #########
  # AUDIO #
  #########

    # ac3 and similar formats not supported due to channel count limitations
    audioCodec="aac" #(aac,flac,ogg,opus)
    audioChannelBitrate="48" #kbps
    audioSampleRate="auto" #(44100,48000,82000,96000,192000,auto)
    audioBitsPerSample="16" #(8,16,24)
    audioChannelMaping="2.0" #(2.0,4.0,5.1-rear,7.1,auto)

  ############
  # CHAPTERS #
  ############

    chaptersInclude="auto" #(no,auto)

  #############
  # SUBTITLES #
  #############

    subtitlesInclude="auto" #(no,auto)
    subtitlesForced="no" #(no,auto)
    subtitlesConvertToSrt="auto" #(no,auto)

  #########
  # VIDEO #
  #########

    videoBitrate="500" #kbps
    videoFrameRate="23.976"
    videoResolution="auto" #(480p,720p,1080p,4k,auto)
    videoCropBlackbars="auto" #(no,auto)
    videoDeinterlace="auto" #(no.auto)

################################################################################
################################### ARKHIVE ####################################
################################################################################

  ###################
  # TERMINAL COLORS #
  ###################

    # Colors
    clR="\033[1;31m"  # Red
    clG="\033[1;32m"  # Green
    clW="\033[1;37m"  # White
    clP="\033[1;35m"  # Purple
    clGa="\033[0;30m" # Gray
    clC="\033[0;36m"  # Cyan (light blue)
    clY="\033[0;33m"  # Yellow
    clU="\033[0;4m"   # Underline
    clD="\033[0;0m"   # default

  #########
  # USAGE #
  #########

    arkhive_usage () {
      eval "printf \"\n\${clC}ARKhive version:\${clG} ${VERSION}
    \${clC}Automated video encoding according to Chlorm's ARK specifications.

    Usage: \${clD}arkhive [\${clU}\${clP}OPTIONS\$clD] \${clU}\${clP}FILE\$clD [\${clU}\${clP}OPTIONS\$clD]\$clD
        \$clG-i|--input  \${clU}\${clP}FILE\$clD          \$clY*\$clD - set input file\$clD
        \$clG-o|--output \${clU}\${clP}DIRECTORY\$clD       - set output directory\$clD
        \$clG-t|--temp   \${clU}\${clP}DIRECTORY\$clD       - set temp directory\$clD
        \$clG-h|--help\$clD                   - print this message
        \$clG-v|--version\$clD                - print version\n\n\""
    }

  ################
  # DEPENDENCIES #
  ################

    # Tests to see if a binary exists in the path
    path_hasbin () {
      [ "$#" -ne "1" ] && return 2
      type $1 >/dev/null 2>&1
    }

    # Optional dependencies
      # Audio codecs
      if [ "$audioCodec" = "aac" ]; then
        path_hasbin fdk-aac ??? || { echo "ERROR: 'fdk-aac' is not installed"; exit 1; }
      fi
      if [ "$audioCodec" = "ogg" ]; then
        path_hasbin ogg ??? || { echo "ERROR: 'ogg' is not installed"; exit 1; }
      fi
      if [ "$audioCodec" = "opus" ]; then
        path_hasbin opus ??? || { echo "ERROR: 'opus' is not installed"; exit 1; }
      fi
      # Subtitle conversion
      if [ "$subtitlesConvertToSrt" = "auto" ]; then
        path_hasbin vobsub2srt ??? || { echo "ERROR: 'vobsub2srt' is not installed"; exit 1; }
      fi
    # Required dependencies
      path_hasbin awk || { echo "ERROR: 'awk' is not installed"; exit 1; }
      path_hasbin cat || { echo "ERROR: 'cat' is not installed"; exit 1; }
      path_hasbin dirname || { echo "ERROR: 'dirname' is not installed"; exit 1; }
      path_hasbin ffmpeg || { echo "ERROR: 'ffmpeg' is not installed"; exit 1; }
      path_hasbin grep || { echo "ERROR: 'grep' is not installed"; exit 1; }
      path_hasbin mkvextract || { echo "ERROR: 'mkvextract' is not installed"; exit 1; }
      path_hasbin mkvmerge || { echo "ERROR: 'mkvmerge' is not installed"; exit 1; }
      path_hasbin pwd || { echo "ERROR: 'pwd' is not installed"; exit 1; }
      path_hasbin rm || { echo "ERROR: 'rm' is not installed"; exit 1; }
      path_hasbin tail || { echo "ERROR: 'tail' is not installed"; exit 1; }
      path_hasbin x265 || { echo "ERROR: 'x265' is not installed"; exit 1; }

  ###############
  # PARSE INPUT #
  ###############

    if [ -z "$1" ]; then
        echo -e "${clR}ERROR: No arguments provided"
        exit 1
    else
      # Parse Arguments
      while [ "$1" ]; do
        case "$1" in
          '-i'|'--input')
            if [ -z "$2" ]; then
              echo -e "${clR}ERROR: No input provided"
              exit 1
            elif [ -f "$2" ]; then
              inputFileExt=${2##*.}
              case "$inputFileExt" in
                'avi'|'f4v'|'flv'|'m2ts'|'m4v'|'mkv'|'mp4'|'mpeg'|'mpg'|'mov'|'ts'|'wmv')
                  userInput="$2"
                  shift
                  ;;
                *)
                  printf "${clR}ERROR: Selected file is not a supported format!\n";
                  printf "${clY}Supported: avi,f4v,flv,m2ts,m4v,mkv,mp4,mpeg,mpg,mov,ts,wmv\n";
                  exit 1
                  ;;
              esac
            else
              printf "${clR}ERROR: Input file does not exist\n"
              exit 1
            fi
            ;;
          '-o'|'--output')
            if [ -z "$2" ]; then
              echo -e "${clR}ERROR: No output directory provided"
              exit 1
            elif [ ! -d "$2" ]; then
              echo -e "${clR}ERROR: Output is not a directory"
              exit 1
            else
              userOutput=$2
              shift
            fi
            ;;
          '-t'|'--temp')
            if [ -z "$2" ]; then
              echo -e "${clR}ERROR: No temp directory provided"
              exit 1
            elif [ ! -d "$2" ]; then
              echo -e "${clR}ERROR: Temp is not a directory"
              exit 1
            else
              userTemp="$2"
              shift
            fi
            ;;
          '-h'|'--help') eval "printf \"${HELP}\"";exit 1;;
          '-v'|'--version')
            printf "ARKhive version: ${VERSION}\n\n";exit 1;;
          -*) eval "printf \"${HELP}\"";printf "\n${clR}ERROR: Unknown option $1\n";exit 1;;
          *)
            if [ -n "${INPATH}" ]; then
              eval "printf \"${HELP}\""
              printf "\n${clR}ERROR: Unknown option $1\n";exit 1
            elif [ ! -r "$1" ]; then
              printf "${clR}ERROR: Unable to read $1\n";exit 1
            else
              INPATH="$1"
            fi
            ;;
        esac
        shift
      done
    fi
    # Confirm user has provided input
    if [ -z "$userInput" ]; then
      eval "printf \"${HELP}\""
      echo -e "${clR}ERROR: no input provided"
      exit 1
    fi

  ############
  # CPU INFO #
  ############

    cpu_cores () {

      cpuCores=$(awk '/^cpu\ cores/{print $4;exit}' /proc/cpuinfo)

      if [ -z "$cpuCores" ]; then
        cpuCores="1"
      fi

      echo "$cpuCores"

    }

    cpu_threads () {

      cpuThreads=$(grep -c ^processor /proc/cpuinfo)

      if [ -z "$cpuCores" ]; then
        cpuThreads="1"
      fi

      echo "$cupThreads"

    }

  #################
  # INPUT HANDLER #
  #################

    input_directory () {
      # Input file directory
      cd $(dirname $userInput)
      pwd
    }

    output_directory () {
      # Output directory
      if [ -z "$userOutput" ]; then
        input_directory
      else
        cd $userOutput
        pwd
      fi
    }

    temp_directory () {
      # Temp directory
      if [ -z "$userTemp" ]; then
        input_directory
      else
        cd $userTemp
        pwd
      fi
    }

    filename () {
      # Input filename w/ ext
      fileName=$(basename "$userInput")

      # Input filename w/o ext
      fileName=$(echo "$fileName" | sed -r 's/\.[[:alnum:]]+$//')

      # Add tag
      arkMark="-ARK"
      echo "$fileName$arkMark"
    }

  ############################
  # CHAPTER STREAM EXTRACTOR #
  ############################

    if [ "$hasChapters" = "true" ] && [ "$chaptersInclude" = "auto" ]; then
      chapter_stream_extractor () {
        # Find chapters if any exist
        hasChapters=$(ffprobe -i $userInput 2>&1 | awk '/Chapter/ { print $2 }')

        # Videos has no chapters
        if [ -z "$hasChapters" ]; then
          echo "Video has no chapters"
        # Video has chapters
        else
          mkvextract \
            chapters \
            --simple $userInput \
            --redirect-output $(temp_directory)/$(filename).xml || \
            { echo "WARNING: Failed to extract chapters from source";\
              return 1; }
        fi
      }
    fi

  #############
  # SUBTITLES #
  #############

    if [ "$hasSubtitles" = "true" ] && [ "$subtitlesInclude" ]; then
      ## TODO: case for subtitle without language set
      ## TODO: use for loop to find all english subs in file
      ##      after finding subs look for plain text subs
      ## TODO: parse vobsub2srt output and remove ERROR:... lines
      ## TODO: add support for PGS subtitles
      ##      if pgs use bdsup2sub to covert to sub/idx and then vobsub2srt

      subtitle_stream_selector () {

        echo "TODO"

      }

      subtitle_stream_extractor () {

        ## [find if video has subtitles]
        hasSubtitles=$(\
          ffprobe $userInput 2>&1 | \
          awk '/Subtitle/ { print $2 }')

        # No subtitles were found
        if [ -f "$(input_directory)/$orginalFilename.srt" ]; then
          cp "$(input_directory)/$orginalFilename.srt" "$(temp_directory)/$(filename).srt"}
        elif [ -z "$hasSubtitles" ]; then
          return 3
        # Subtitles were found
        else
          # Finds first english subtitle stream]
          subtitleStream=$(\
            ffmpeg -i $userInput -f null - 2>&1 | \
            grep -m 1 -o -P '(?<=Stream).*(?=\(eng\):\ Subtitle)' | \
            awk -F ":" '{print $2}' | tail -1)

          if [ -z "subtitleStream" ]; then
            echo "no english subtitles found"
          fi

          mkvextract -q tracks $userInput $subtitleStream:temp_directory/filename 2>/dev/null
          echo -e "       ${clC}Found English Subs, Stream: ${clP}$subtitleStream"

          ## [check for and convert VobSub to SRT]
          if [ -f "$tempFilePath/$fileName.idx" ]; then
            echo "         Converting VobSub to SRT"
            vobsub2srt $(temp_directory)/$(filename) &>/dev/null || \
            { echo "WARNING: failed to convert vobsub to srt"; }
          fi
        fi

      }
    fi

  ##############################
  # SUBTITLE CONVERSION TO SRT #
  ##############################

    if [ "subtitlesNotSrt" = "true" ] && [ "$subtitlesConvertToSrt" = "auto" ]; then

        subtitle_srt_converter () {

          echo "TODO"

        }

    fi

  #########################
  # AUDIO STREAM SELECTOR #
  #########################

    ## UNSUPPORTED: avi with multiple audio streams
    ## CONTAINERS WITH NO LANGUAGE CODES: avi,m2ts,ts
    audio_stream_selector () {
      # Add all streams with audio into an array
      # <There is a lot or trickery required to get the stream
      #  number that is container specific, so 'or' statements were
      #  added to work around this>
      audioStreamArray=($(\
        ffprobe -i test4.mp4 2>&1 | \
        grep "Audio:" | \
        awk '/Stream\ #0:/ { print $2 }' | \
        grep -o -P '(?<=\#0\:)[0-9](?=\([a-z]+\)|\[[0-9]+x[0-9]+\]|\:)'))

      # Find total number of audio streams in the container
      audioStreamCount=$(${#audioStreamArray[@]})

      if [ -z "$audioStreamCount" ]; then
        echo "WARNING: No audio streams found"
      elif [ "$audioStreamCount" = "1" ]; then
        # Set stream number to the only one found
        audioPrefferedStream=$($audioStreamArray[1])

      # Containers with: mkv,mp4
      # MP4 has two audio lines, only one with a stream section
      elif [ "$audioStreamCount" -gt "1" ]; then
        # get pounded in the ass

        # Not sure where to start with this section

      # Find language of audio stream
      ffprobe -i test4.mp4 2>&1 | \
        # Gets line of streams
        grep "Stream #0:1" | \
        # Pulls first part of line containing language
        awk '/Stream\ #0:1/ { print $2 }' | \
        # Pulls the three digit language code
        # ISO 639-2/B
        grep -m 1 -o -P '(?<=\#0\:1\().*(?=\):)'
      # 3 
      #  if only one audio stream take it
      #  if not, see if any audio streams contain english
      #    if so, see if there are multiples
      #      select best option 
      #  if not, see if there is anything other than "und"
      #  if not, see if there are multiple und
      #    if so, pick best option
      else
        echo "ERROR: Video has no audio"
        exit 2
      fi

      # 4 Fuck Bitches
    }
        
    audio_input_sample_rate () {
      ffprobe -i $userInput 2>&1 | \
        grep -m 1 "Stream #0:$primaryAudioStream" | \
        awk -F ", " '/Hz/ { print $2 }'
    }

  ########################
  # AUDIO CHANNEL MAPPER #
  ########################

    ## TODO: add support to automatically remap surround-sound channels in a consistent manner
    ## get rid of 5.1(side)  it is annoying on a 7.1 setup even if it is technically extended stereo
    audio_channel_mapper () {
      # Finds channel layout
      # TODO: add $(audio_input_samplerate) function
      findChannelLayout=$(ffprobe -i $userInput 2>&1 | \
        grep -m 1 "Stream #0:$primaryAudioStream" | \
        awk -F ", " '/44100\ Hz/ { print $3 }')

      # Determine channel layout for later use
      # https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/channel_layout.c
      # https://github.com/FFmpeg/FFmpeg/blob/master/doc/utils.texi

      # 0 = FL - Front Left
      # 1 = FR - Front Right
      # 2 = FC - Front Center
      # 3 = LFE - Low Frequency
      # 4 = BL - Back Left
      # 5 = BR - Back Fight
      # 6 = FLC - Front Left-of-Center
      # 7 = FRC - Front Right-of-Center
      # 8 = BC - Back Center
      # 9 = SL - Side Left
      # 10 = SR - Side Right
      # 11 = TC - Top Center
      # 12 = TFL - Top Front Left
      # 13 = TFC - Top Front Center
      # 14 = TFR - Top Front Right
      # 15 = TBL - Top Back Left
      # 16 = TBC - Top Back Center
      # 17 = TBR - Top Back Right
      # 29 = DL - Downmix Left
      # 30 = DR - Downmix Right
      # 31 = WL - Wide Left
      # 32 = WR - Wide Right
      # 33 = SDL - Surround Direct Right
      # 34 = SDR - Surround Direct Left
      # 35 = LFE2 - Low Frequency 2

      # TODO: for 5.1 and others re-map 5.1(side) to 5.1(rear)
      # TODO: 

      case "$findChannelLayout" in
        '')
          echo "ERROR: could not detect audio channel layout"
          exit 1
        'mono')
          audioChannels="1"
          # AV_CH_LAYOUT_MONO
          # FC
        'stereo')
          audioChannels="2"
          # AV_CH_LAYOUT_STEREO
          # FL+FR
        '2.1')
          audioChannels="3"
          # AV_CH_LAYOUT_2POINT1
          # FL+FR+LFE
        '3.0')
          audioChannels="3"
          # AV_CH_LAYOUT_SURROUND
          # FL+FR+FC
        '3.0(back)'
          audioChannels="3"
          # AV_CH_LAYOUT_2_1
          # FL+FR+BC
        '4.0')
          audioChannels="4"
          # AV_CH_LAYOUT_4POINT0
          # FL+FR+FC+BC
        'quad')
          audioChannels="4"
          # AV_CH_LAYOUT_QUAD
          # FL+FR+BL+BR
        'quad(side)')
          audioChannels="2"
          # AV_CH_LAYOUT_2_2
          # FL+FR+SL+SR
        '3.1')
          audioChannels="4"
          # AV_CH_LAYOUT_3POINT1
          # FL+FR+FC+LFE
        '4.1')
          audioChannels="5"
          # AV_CH_LAYOUT_4POINT1
          # FL+FR+FC+LFE+BC
        '5.0')
          audioChannels="5"
          # AV_CH_LAYOUT_5POINT0_BACK
          # FL+FR+FC+BL+BR
        '5.0(side)')
          audioChannels="5"
          # AV_CH_LAYOUT_5POINT0
          # FL+FR+FC+SL+SR
        '5.1')
          audioChannels="6"
          # AV_CH_LAYOUT_5POINT1_BACK
          # FL+FR+FC+LFE+BL+BR
        '5.1(side)')
          audioChannels="6"
          # AV_CH_LAYOUT_5POINT1
          # FL+FR+FC+LFE+SL+SR
        '6.0')
          audioChannels="6"
          # AV_CH_LAYOUT_6POINT0
          # FL+FR+FC+BC+SL+SR
        '6.0(front)')
          audioChannels="6"
          # AV_CH_LAYOUT_6POINT0_FRONT
          # FL+FR+FLC+FRC+SL+SR
        'hexagonal')
          audioChannels="6"
          # AV_CH_LAYOUT_HEXAGONAL
          # FL+FR+FC+BL+BR+BC
        '6.1')
          audioChannels="7"
          # AV_CH_LAYOUT_6POINT1
          # FL+FR+FC+LFE+BC+SL+SR
        '6.1(back)')
          audioChannels="7"
          ## TODO: fix upstream
          # actually 6.1, not 6.1(back), upstream typo
          # AV_CH_LAYOUT_6POINT1_BACK
          # FL+FR+FC+LFE+BL+BR+BC
        '6.1(front)')
          audioChannels="7"
          # AV_CH_LAYOUT_6POINT1_FRONT
          # FL+FR+LFE+FLC+FRC+SL+SR
        '7.0')
          audioChannels="7"
          # AV_CH_LAYOUT_7POINT0
          # FL+FR+FC+BL+BR+SL+SR
        '7.0(front)')
          audioChannels="7"
          # AV_CH_LAYOUT_7POINT0_FRONT
          # FL+FR+FC+FLC+FRC+SL+SR
        '7.1')
          audioChannels="8"
          # AV_CH_LAYOUT_7POINT1
          # FL+FR+FC+LFE+BL+BR+SL+SR
        '7.1(wide)')
          audioChannels="8"
          # AV_CH_LAYOUT_7POINT1_WIDE_BACK
          # FL+FR+FC+LFE+BL+BR+FLC+FRC
        '7.1(wide-side)')
          audioChannels="8"
          # AV_CH_LAYOUT_7POINT1_WIDE
          # FL+FR+FC+LFE+FLC+FRC+SL+SR
        'octagonal')
          audioChannels="8"
          # AV_CH_LAYOUT_OCTAGONAL
          # FL+FR+FC+BL+BR+BC+SL+SR
        'downmix')
          audioChannels="2"
          # AV_CH_LAYOUT_STEREO_DOWNMIX
          # DL+DR
        *)
          echo "ERROR: Unsupported channel layout"
          exit 1
      esac
    }

  #################
  # AUDIO ENCODER #
  #################

    audio () {
      audio_channel_layout
      # Bitrate per channel (set to 48kbps)
      audioBitrate=$(($audioChannels * 48))
      audioBitrateUnit="k"
      audioBitrate="$audioBitrate$audioBitrateUnit"
    }
    audio_encoder () {
      # Encode Audio
      ffmpeg \
      -i "$userInput" \
      -c:a libfdk_aac \
      -map 0:$audioEngStream \
      -ac $audioChannels \
      -b:a $audioBitrate \
      -ar 48000 \
      -y $(temp_directory)/$(filename).aac || \
      { echo -e "${clR}ERROR: audio failed to encode" ; exit 0 ; }
    }

  ############################
  # BLACK BAR CROP DETECTION #
  ############################

    if [ "$videoCropBlackbars" = "true" ]; then
      black_bar_crop_detection () {
        ## [several checks to accurately crop black-bars]
        crop="1"
        totalLoops="10"
        ## [gather crop values]
        A=0
        while [ "$A" -lt "$totalLoops" ]; do
          A="$(( $A + 1 ))"
          skipSecs="$(( 120 * $A ))"
          crop[$A]=$(\
            ffmpeg -threads $(cpu_cores) -i $userInput -ss $skipSecs \
            -t 1 -vf cropdetect -f null - 2>&1 | \
            awk -F "=" '/crop/ { print $NF }' | tail -1)
          echo -ne "\r       ${clC}crop detect ${clP}$A ${clC}of ${clP}10 ${clC}complete"
        done
        B=0
        while [ "$B" -lt "$totalLoops" ]; do
          B="$(( $B + 1 ))"
          C=0
          while [ "$C" -lt "$totalLoops" ]; do
            C="$(( $C + 1 ))"
            if [ "${crop[$B]}" == "${crop[$C]}" ]; then
              countCrop[$B]="$(( ${countCrop[$B]} + 1 ))"
            fi
          done
        done
        ## [find greatest crop]
        highestCount=0
        D=0
        while [ "$D" -lt "$totalLoops" ]; do
          D="$(( $D + 1 ))"
          if [ "${countCrop[$D]}" -gt "$highestCount" ]; then
            highestCount="${countCrop[$D]}"
            greatest="$D"
          fi
        done
        ## [final crop value]
        crop="${crop[$greatest]}"
        ## [frame width from final crop value]
        cropWidth=$(echo $crop | awk -F ":" '{print $1}')
        echo -e "\n             Crop: ${clP}$crop"
      }
    fi

  #############################
  # VIDEO INTERLACE DETECTION #
  #############################

    if [ "$videoDeinterlace" = "auto" ]; then
      video_interlace_detection () {
        echo "Not implemented yet"
      }
    fi

  #################
  # VIDEO ENCODER #
  #################

    video_encoder () {
      # Frames Per Second
      FPS="23.976023976"
      # Get Duration
      totalLength=$(ffprobe "$userInput" 2>&1 | sed -n "s/.* Duration: \([^,]*\), .*/\1/p")
      HRS=$(echo $totalLength | cut -d":" -f1)
      MIN=$(echo $totalLength | cut -d":" -f2)
      SEC=$(echo $totalLength | cut -d":" -f3)
      # Get total number of frames
      totalFrames=$(echo "($HRS*3600+$MIN*60+$SEC)*$FPS" | bc | cut -d"." -f1)
      echo "Estimated total frames: $totalFrames"

      # Number of encoding passes
      passes="2"

      # Initial pass number, DO NOT CHANGE VALUE
      PASS="1"

      while [ $PASS -le $passes ]; do

        echo -e "${clC}Encoding Pass: ${clP}$PASS ${clC}of ${clP}$passes${clD}"

        ## [ffmpeg piped to x265]
        ## TODO: determine if crop height or width are odd numbers and if so
        ##        enable ffmpeg scaling otherwise disable
        ## TODO: make ffmpeg output to $fileName.ffmpeg
        ffmpeg \
          -threads $(cpu_threads) \
          -i "$userInput" \
          -vf "crop=$crop,scale=$cropWidth:trunc(ow/a/2)*2" \
          -r 24000/1001 \
          -pix_fmt yuv420p \
          -f yuv4mpegpipe - 2> nul | \
        x265 \
          --y4m \
          --stats=$tempFilePath/$fileName.stats \
          --threads=$(cpu_cores) \
          --frame-threads=$cpuCores \
          --wpp \
          --ctu=64 \
          --no-cutree \
          --tu-intra-depth=4 \
          --tu-inter-depth=4 \
          --me=2 \
          --cbqpoffs=3 \
          --crqpoffs=3 \
          --psy-rd=0.15 \
          --subme=7 \
          --merange=60 \
          --ref=4 \
          --bframes=3 \
          --b-pyramid \
          --b-adapt=2 \
          --bframe-bias=0 \
          --b-intra \
          --weightb \
          --weightp \
          --bitrate=1024 \
          --vbv-init=0.9 \
          --vbv-bufsize=31250 \
          --vbv-maxrate=31250 \
          --no-slow-firstpass \
          --pass=$PASS \
          --keyint=250 \
          --min-keyint=23 \
          --rc-lookahead=60 \
          --no-constrained-intra \
          --aq-mode=0 \
          --lft \
          --sao-lcu-opt=1 \
          --cbqpoffs=-3 \
          --crqpoffs=-3 \
          --rect \
          --amp \
          --max-merge=5 \
          --no-early-skip \
          --no-tskip \
          --hash=2 \
          -f 0 \
          -o "$(temp_directory)/$(filename).hvc" - || \
          { echo "ERROR: video encoding failed";exit 0; }

        # Finished encoding
        if [ $PASS == $passes ]; then
          echo
          echo "Encoding complete"
        # Not finised encoding
        else 
          echo
        fi

        # Increment pass count
        PASS="$(( $PASS + 1 ))"
      done
    }

  #########
  # MUXER #
  #########

    muxer () {
      # mkvmerge
      # -o "$rar_variable-s.mkv"
      # "--default-track" "0:yes"
      # "--forced-track" "0:no"
      # "--language" "1:eng"
      # "--track-name"
      # "1:English"
      # "--default-track"
      # "1:yes"
      # "--forced-track"
      # "1:no"
      # "--language" "2:eng"
      # "--default-track" "2:yes" "--forced-track"
      # "2:no" "-a" "1" "-d" "0" "-s" "2" "-T" "--no-global-tags"
      # "--no-chapters" "(" "$rlsname_variable.mkv" ")"
      # "--track-order" "0:0,0:1,0:2" "--split" "parts:00:01:30-00:02:30"

      ## [check for chaper file]
      if [ -f "$(temp_directory)/$(filename).xml" ]; then
        muxChapters="--chapters $(temp_directory)/$(filename).xml"
      else
        muxChapters=""
      fi

      ## [check for subtitle file]
      if [ -f "$(temp_directory)/$(filename).srt" ]; then
        muxSubtitles="$(temp_directory)/$(filename).srt"
      else
        muxSubtitles=""
      fi

      ## TODO: find audio language and set videolanguage to audiolanguage
      mkvmerge \
          -o $(output_directory)/$(filename).mkv \
          --title $(filename) \
          -A $(temp_directory)/$(filename).hvc \
          $muxChapters \
          $muxSubtitles \
          $(temp_directory)/$(filename).aac
    }

  ######################
  # CLEANUP TEMP FILES #
  ######################

    ## ffmpeg redirected output [nul]

    ## [delete video]
    if [ -f "$(temp_directory)/$(filename).hvc" ]; then
      rm $(temp_directory)/$(filename).hvc
      echo "Removed $(filename).hvc"
    fi

    ## [delete x265 multi-pass log]
    if [ -f "$(temp_directory)/$(filename).stats" ]; then
      rm $(temp_directory)/$(filename).stats
      echo "Removed $(filename).stats"
    fi

    ## [delete audio]
    if [ -f "$(temp_directory)/$(filename).opus" ]; then
      rm $(temp_directory)/$(filename).aac
      echo "Removed $(filename).aac"
    fi

    ## [delete subtitles]
    if [ -f "$(temp_directory)/$(filename).sub" ]; then
      rm $(temp_directory)/$(filename).sub
      echo "Removed $(filename).sub"
    fi
    if [ -f "$(temp_directory)/$(filename).idx" ]; then
      rm $(temp_directory)/$(filename).idx
      echo "Removed $(filename).idx"
    fi
    if [ -f "$(temp_directory)/$(filename).srt" ]; then
      rm $(temp_directory)/$(filename).srt
      echo "Removed $(filename).srt"
    fi

    ## [delete chapter list]
    if [ -f "$(temp_directory)/$(filename).xml" ]; then
      rm $(temp_directory)/$(filename).xml
      echo "Removed $(filename).xml"
    fi