#!bash

#                                  Arkive
#
# Copyright (c) 2013-2017, Cody Opel <codyopel@gmail.com>
# All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# FIXME: merge back into single executable

################################################################################

set -o errexit
set -o errtrace
set -o functrace
set -o pipefail

################################################################################

#PATH#

LOG_LEVEL='debug'

ARKIVE_VERSION='0.1.0'

ARKIVE_PREFIX="$(readlink -f "$(readlink -f "$(dirname "$(readlink -f "${0}")")")"/..)"
ARKIVE_LIB_DIR="${ARKIVE_PREFIX}/share/arkive"

PROGRAM_NAME='arkive'

################################ Load Libraries ################################

source "$(lib-bash)"

wait

while read LoadLibrary ; do
  source "$(readlink -f "${LoadLibrary}")"
done < <(find "${ARKIVE_LIB_DIR}" -type f -iname '*.bash')

wait

#################################### Traps #####################################

trap 'Log::Func' DEBUG
trap 'Tmp::Cleanup' SIGINT SIGTERM
trap -- 'Tmp::Cleanup ; Log::Trace ; exit 1' ERR

##################################### Main #####################################

function Arkive::Main {
  Function::RequiredArgs '0' "$#"
  local __filename__
  local __filenamefmt__
  local __outputdir__
  local __subtitlestreams__
  local __tmpdir__

  local -a Audio
  local AudioPass
  local FFmpegArg
  local -a FFmpegArgs
  local FFmpegArgsList
  local File
  local Index=0
  local Subtitle
  local Metadata
  local OutputFile
  local -a StreamIndexMap

  # Stream identifiers
  local as
  local asa

  File="${INPUTFILE}"
  __filename__="$(Filename::Original.base "${File}")"
  __filenamefmt__="$(Filename::Formatted "${File}")"
  __tmpdir__="${TMPDIR}"
  __outputdir__="${OUTPUTDIR}"
  OutputFile="${__outputdir__}/${__filenamefmt__}.${FFMPEG_CONTAINER_FORMAT}"

  #FFprobe 'v' '-' 'stream' 'index' "${File}"

  asa=($(Stream::Select 'audio' "${File}"))
  [[ ${#asa[@]} == 1 ]]  # Limit to one
  for as in ${asa[@]}; do
    # Assign stream index, assuming video is 0, and audio starts from 1 ->
    # number of streams + 1.
    StreamIndexMap[${Index}]="-map 0:${as}"
    Audio+=($(FFmpeg::Audio "${as}" "${File}" "${Index}"))
  done

  # Metadata
  #Metadata="$(FFmpeg::Metadata)"

  # Always overwrite the file for multipass encodes or if requestedaaaaaa
  if ${ARKIVE_ALLOW_OVERWRITING_FILES}; then
    FFmpegArgs+=('-y')
  else
    FFmpegArgs+=('-n')
  fi
  FFmpegArgs+=(
    '-nostdin'
    '-hide_banner'
    '-stats'
    '-loglevel' 'info'
    '-i' "${File}"
    '-threads' '1'
    '-map_metadata' '0'
  )
  FFmpegArgs+=(${StreamIndexMap[@]})
  FFmpegArgs+=("${Audio[@]}")
  FFmpegArgs+=("${OutputFile}")

  echo "ffmpeg ${FFmpegArgs[@]}"
  ffmpeg "${FFmpegArgs[@]}"

  unset FFmpegArg FFmpegArgs FFmpegArgsList
  __pass__=$(( ${__pass__} + 1 ))
}

################################## Execution ###################################

Requires::Check

Input::Parser "${@}"

Arkive::Main

Tmp::Cleanup

exit 0
